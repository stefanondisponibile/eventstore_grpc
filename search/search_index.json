{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EventStore Python GRPC","text":"<p>Interact with EventStoreDB via GRPC.</p>"},{"location":"#installation","title":"Installation","text":"pip install eventstore_grpc Installing..."},{"location":"#usage","title":"Usage","text":"<p>Check out the quickstart.</p>"},{"location":"#reference","title":"Reference","text":"<p>See the reference for more.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>If you want to test the client you will need some EventStoreDB instance to interact with. You can have a look at this quickstart, but if you're short on time and you have <code>docker compose</code> installed on your machine, here's your shortcut:</p> <pre><code>curl -o docker-compose-eventstore-3nodes.yaml https://raw.githubusercontent.com/stefanondisponibile/eventstore_grpc/master/docker-compose.yaml &amp;&amp; \\\ndocker compose -f docker-compose-eventstore-3nodes.yaml up -d &amp;&amp; \\\ndocker compose logs\n</code></pre> <p>This downloads a docker compose file to setup an EventStoreDB instance with 3 nodes.</p> <p>If you cloned the <code>eventstore_grpc</code> repository you can skip the <code>curl</code> part and use the <code>docker-compose.yaml</code> file directly.</p> <p>Note</p> <p>The docker compose file generates SSL certificates and puts them in a <code>certs</code> folder on your local directory. You can delete that directory, but since it was generated by a docker container you will need to be <code>root</code>. For example, if you want to clean everything up when you're done, you can run the following:</p> <pre><code>docker compose down -v &amp;&amp; sudo rm -rf ./certs docker-compose-eventstore-3nodes.yaml\n</code></pre> <p>If you want, you can explore the EventStoreDB Admin UI pointing your browser to https://localhost:2111.</p>"},{"location":"quickstart/#creating-a-client","title":"Creating a client","text":"<p>Our EventStoreDB instance is running 3 nodes at the followings <code>hosts</code>:</p> <ul> <li><code>localhost:2111</code></li> <li><code>localhost:2112</code></li> <li><code>localhost:2113</code></li> </ul> <p>We want to use <code>tls</code> for secure connections, we're going to read the certificates from the folder that was created with docker compose (<code>./certs/ca/ca.crt</code>) and we're going to use the default admin credentials (<code>admin</code>, <code>changeit</code>).</p> <pre><code>from eventstore_grpc import EventStore\nes = EventStore(\nhosts=[\"localhost:2111\", \"localhost:2112\", \"localhost:2113\"],\ntls=True,\ntls_ca_file=\"certs/ca/ca.crt\",\nusername=\"admin\",\npassword=\"changeit\",\n)\n</code></pre>"},{"location":"quickstart/#getting-information-about-the-cluster","title":"Getting information about the cluster","text":"<p>Now that we have a client, we can get some information about it:</p> <pre><code>cluster_info = es.gossip.get_cluster_info()\nprint(cluster_info)\n</code></pre> <p>This should tell you something like this:</p> <pre><code>members {\ninstance_id {\nstructured {\nmost_significant_bits: 766833313904807028\nleast_significant_bits: -7167183254000776328\n}\n}\ntime_stamp: 16882865214981958\nstate: Follower\nis_alive: true\nhttp_end_point {\naddress: \"127.0.0.1\"\nport: 2113\n}\n}\nmembers {\ninstance_id {\nstructured {\nmost_significant_bits: -1389199217038570244\nleast_significant_bits: -6286225797498614732\n}\n}\ntime_stamp: 16882865215001644\nstate: Leader\nis_alive: true\nhttp_end_point {\naddress: \"127.0.0.1\"\nport: 2112\n}\n}\nmembers {\ninstance_id {\nstructured {\nmost_significant_bits: 4006561881348851895\nleast_significant_bits: -7528605218151893547\n}\n}\ntime_stamp: 16882865213735606\nstate: Follower\nis_alive: true\nhttp_end_point {\naddress: \"127.0.0.1\"\nport: 2111\n}\n}\n</code></pre> <p>The <code>gossip.get_cluster_info</code> endpoint returns a <code>ClusterInfo</code> protobuf message, so you can use it directly. For example, you can check if all your nodes are alive:</p> <pre><code>assert all(member.is_alive for member in cluster_info.members)\n</code></pre> <p>Or you can check each node's state (e.g. to understand if one's a Leader or Follower):</p> <pre><code>from eventstore_grpc.proto.gossip_pb2 import MemberInfo\nfor member in cluster_info.members:\nstate_name = MemberInfo.VNodeState.Name(member.state)\nhttp_end_point = f\"{member.http_end_point.address}:{member.http_end_point.port}\"\nprint(f\"Node {http_end_point} is {state_name}\")\n</code></pre> <p>Note</p> <p>Here we're importing <code>MemberInfo</code> from <code>eventstore_grpc.proto.gossip_pb2</code> to resolve the name of each <code>member</code>'s <code>state</code> <code>enum</code> value.</p> <p>Here you can find the complete reference to EventStoreDB's protobuf definitions. You can import any of the compiled protos from <code>eventstore_grpc.proto</code>.</p>"},{"location":"quickstart/#creating-events","title":"Creating events","text":"<p>To produce and consume events we use EventData objects. Each event will have a unique id, a type, some data to represent the event itself. Additionally, you can store some metadata along side if you want to add some \"context\" to the event that you're story with information that's not part of the event itself, like correlations ids, timestamps, access information.</p> <p>Note</p> <p><code>EventData</code> is roughly equivalent to what EventData represents in other EventStoreDB grpc clients.</p> <p>You can create your own custom types of <code>EventData</code>, but it's common to use <code>JSON</code> format to store event payloads, which is convenient also to use some of the built-in features of EventStoreDB such as projections. This library provides a <code>JSONEventData</code> class that you can use to create Events with a JSON payload:</p> <pre><code>from eventstore_grpc import JSONEventData\nevent_1 = JSONEventData(type=\"some_event_occurred\", data={\"foo\": \"bar\"})\nevent_2 = JSONEventData(type=\"some_other_event_occurred\", data={\"baz\": 42}, event_id=\"40db443a-6244-472b-87c1-e8e87c8a3abf\")\nevent_3 = JSONEventData(type=\"something-happened\", data=None, metadata={\"some\": \"custom-metadata\"})\n</code></pre> <p>Note</p> <p>In <code>event_1</code> we didn't provide any <code>event_id</code>. The <code>JSONEventData</code> object will create a <code>uuid.uuid4</code> id automatically in such cases. Bear in mind that the <code>event_id</code> must be a valid Uuid.</p>"},{"location":"quickstart/#publishing-events","title":"Publishing events","text":"<p>In EventStoreDB when you publish some event you will append it to some stream. You can think of a stream as an ordered collection of events.</p> <p>All you have to do to append some events to a stream is creating the events and deciding a name for your stream:</p> <pre><code>stream_name = \"some-stream\"\n</code></pre> <p>We can append a list of events:</p> <pre><code>response = es.streams.append_to_stream(stream=stream_name, events=[event_1, event_2])\nprint(response)\n</code></pre> <pre><code>success {\ncurrent_revision: 1\nposition {\ncommit_position: 6914\nprepare_position: 6914\n}\n}\n</code></pre> <p>Or one at a time:</p> <pre><code>response = es.streams.append_to_stream(stream=stream_name, events=event_3)\nprint(response)\n</code></pre> <pre><code>success {\ncurrent_revision: 2\nposition {\ncommit_position: 7053\nprepare_position: 7053\n}\n}\n</code></pre>"},{"location":"quickstart/#reading-events","title":"Reading events","text":"<p>We have different options to read events from a stream, but for this quickstart let's keep it simple and say that we want to read all the events that we just published (i.e from the start of our <code>some-stream</code> stream).</p> <pre><code>events = es.streams.read_from_stream(stream_name)\nfor event in events:\nprint(event)\n</code></pre> <pre><code>event {\nevent {\nid {\nstring: \"8c253ce9-02ec-42d8-b7df-7607c2dc91d3\"\n}\nstream_identifier {\nstream_name: \"some-stream\"\n}\nprepare_position: 18446744073709551615\ncommit_position: 18446744073709551615\nmetadata {\nkey: \"type\"\nvalue: \"some_event_occurred\"\n}\nmetadata {\nkey: \"created\"\nvalue: \"16882945222373749\"\n}\nmetadata {\nkey: \"content-type\"\nvalue: \"application/json\"\n}\ncustom_metadata: \"{}\"\ndata: \"{\\\"foo\\\": \\\"bar\\\"}\"\n}\nno_position {\n}\n}\nevent {\nevent {\nid {\nstring: \"40db443a-6244-472b-87c1-e8e87c8a3abf\"\n}\nstream_identifier {\nstream_name: \"some-stream\"\n}\nstream_revision: 1\nprepare_position: 18446744073709551615\ncommit_position: 18446744073709551615\nmetadata {\nkey: \"type\"\nvalue: \"some_other_event_occurred\"\n}\nmetadata {\nkey: \"created\"\nvalue: \"16882945222374129\"\n}\nmetadata {\nkey: \"content-type\"\nvalue: \"application/json\"\n}\ncustom_metadata: \"{}\"\ndata: \"{\\\"baz\\\": 42}\"\n}\nno_position {\n}\n}\nevent {\nevent {\nid {\nstring: \"db4a5a73-f4ce-4760-974d-97ad5091789c\"\n}\nstream_identifier {\nstream_name: \"some-stream\"\n}\nstream_revision: 2\nprepare_position: 18446744073709551615\ncommit_position: 18446744073709551615\nmetadata {\nkey: \"type\"\nvalue: \"something-happened\"\n}\nmetadata {\nkey: \"created\"\nvalue: \"16882945889580381\"\n}\nmetadata {\nkey: \"content-type\"\nvalue: \"application/json\"\n}\ncustom_metadata: \"{\\\"some\\\": \\\"custom-metadata\\\"}\"\ndata: \"null\"\n}\nno_position {\n}\n}\n</code></pre>"},{"location":"quickstart/#going-further","title":"Going further","text":"<p>So far you've learned how to:</p> <ul> <li>connect to EventStoreDB</li> <li>getting information about the nodes of the cluster</li> <li>creating some events</li> <li>appending events to some stream</li> <li>reading from the stream</li> </ul> <p>There's much more you can do with EventStoreDB and we're constantly trying to improve our documentation. We will add some sections to cover intermediate/advanced use cases.</p> <p>For now, please use the API reference.</p>"},{"location":"reference/eventstore_grpc/__init__/","title":"init","text":""},{"location":"reference/eventstore_grpc/constants/","title":"Constants","text":"<p>Shared constant values.</p>"},{"location":"reference/eventstore_grpc/constants/#eventstore_grpc.constants.BACKWARDS","title":"<code>BACKWARDS = 'BACKWARDS'</code>  <code>module-attribute</code>","text":""},{"location":"reference/eventstore_grpc/constants/#eventstore_grpc.constants.BACKWARDS--revision-positions","title":"Revision positions.","text":""},{"location":"reference/eventstore_grpc/constants/#eventstore_grpc.constants.END","title":"<code>END = 'END'</code>  <code>module-attribute</code>","text":""},{"location":"reference/eventstore_grpc/constants/#eventstore_grpc.constants.END--others","title":"OTHERS","text":""},{"location":"reference/eventstore_grpc/constants/#eventstore_grpc.constants.STREAM_EXISTS","title":"<code>STREAM_EXISTS = 'STREAM_EXISTS'</code>  <code>module-attribute</code>","text":""},{"location":"reference/eventstore_grpc/constants/#eventstore_grpc.constants.STREAM_EXISTS--directions","title":"Directions","text":""},{"location":"reference/eventstore_grpc/discovery/","title":"Discovery","text":"<p>Discovery and gossip helpers.</p>"},{"location":"reference/eventstore_grpc/discovery/#eventstore_grpc.discovery.determine_best_node","title":"<code>determine_best_node(preference, members)</code>","text":"<p>Selects the best node, given a <code>preference</code>.</p> <p>Parameters:</p> Name Type Description Default <code>preference</code> <code>gossip_pb2.MemberInfo.VNodeState</code> <p>the type of node that you want to choose (e.g. <code>leader</code>).</p> required <code>members</code> <code>Iterable[gossip_pb2.MemberInfo]</code> <p>a list of nodes (as gossip_pb2.MemeberInfo objects) to choose from.</p> required <p>Returns:</p> Type Description <code>gossip_pb2.MemberInfo</code> <p>The selected node from members, of None if none of the objects satisfies the</p> <code>gossip_pb2.MemberInfo</code> <p>requested preference.</p> Source code in <code>src/eventstore_grpc/discovery.py</code> <pre><code>def determine_best_node(\npreference: gossip_pb2.MemberInfo.VNodeState,\nmembers: Iterable[gossip_pb2.MemberInfo],\n) -&gt; gossip_pb2.MemberInfo:\n\"\"\"Selects the best node, given a `preference`.\n    Args:\n        preference: the type of node that you want to choose (e.g. `leader`).\n        members: a list of nodes (as gossip_pb2.MemeberInfo objects) to choose from.\n    Returns:\n        The selected node from members, of None if none of the objects satisfies the\n        requested preference.\n    \"\"\"\ncandidates = [member for member in members if member.state is preference]\nreturn random.choice(candidates) if candidates else None\n</code></pre>"},{"location":"reference/eventstore_grpc/discovery/#eventstore_grpc.discovery.discover_endpoint","title":"<code>discover_endpoint(candidates, credentials=None, max_discovery_attempts=10, vnode_state=gossip_pb2.MemberInfo.Leader)</code>","text":"<p>Discovers an endpoint to connect to.</p> <p>Parameters:</p> Name Type Description Default <code>candidates</code> <code>List</code> <p>a list of candidates nodes to use for discovery.</p> required <code>credentials</code> <code>grpc.ChannelCredentials</code> <p>the channel credentials to use for listing cluster members.</p> <code>None</code> <code>max_discovery_attempts</code> <code>int</code> <p>the maximum number of discovery attempts that will be                     made to determine the best node.</p> <code>10</code> <p>Returns:</p> Type Description <code>str</code> <p>The url of the selected node.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>when it's not possible to match any node.</p> Source code in <code>src/eventstore_grpc/discovery.py</code> <pre><code>def discover_endpoint(\ncandidates: List,\ncredentials: grpc.ChannelCredentials = None,\nmax_discovery_attempts: int = 10,\nvnode_state: gossip_pb2.MemberInfo.VNodeState = gossip_pb2.MemberInfo.Leader,\n) -&gt; str:\n\"\"\"Discovers an endpoint to connect to.\n    Args:\n        candidates: a list of candidates nodes to use for discovery.\n        credentials: the channel credentials to use for listing cluster members.\n        max_discovery_attempts: the maximum number of discovery attempts that will be\n                                made to determine the best node.\n    Returns:\n        The url of the selected node.\n    Raises:\n        Exception: when it's not possible to match any node.\n    \"\"\"\ndiscover_attempts = 0\nwhile discover_attempts &lt; max_discovery_attempts:\ndiscover_attempts += 1\nfor candidate in candidates:\ntry:\nmembers = list_cluster_members(\ncandidate,\ncredentials,\n)\nmember_info = determine_best_node(vnode_state, members)\nif member_info is not None:\nendpoint = member_info.http_end_point\nreturn f\"{endpoint.address}:{endpoint.port}\"\nexcept Exception as err:\nlog.error(f\"Failed to get cluster list from: {candidate}\")\nraise err\nraise Exception(\"Couldn't match an endpoint.\")  # pragma: nocover\n</code></pre>"},{"location":"reference/eventstore_grpc/discovery/#eventstore_grpc.discovery.list_cluster_members","title":"<code>list_cluster_members(uri, credentials)</code>","text":"<p>Lists cluster memeber using the provided uri to connect to the cluster.</p> <p>You can use this function to get information about the nodes in the cluster. The MemberInfo objects returned can give information like the state of the node (Initializing, Leader, ...), the instance id, is_alive, and the endpoint of the node (address, port).</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>the URI that will be used to connect to the node.</p> required <code>credentials</code> <code>grpc.ChannelCredentials</code> <p>the ChannelCredentials to use to connect to the node.</p> required <p>Returns:</p> Type Description <code>Iterable[gossip_pb2.MemberInfo]</code> <p>The nodes information as gossip_pb2.MemberInfo objects.</p> Source code in <code>src/eventstore_grpc/discovery.py</code> <pre><code>def list_cluster_members(\nuri: str, credentials: grpc.ChannelCredentials\n) -&gt; Iterable[gossip_pb2.MemberInfo]:\n\"\"\"Lists cluster memeber using the provided uri to connect to the cluster.\n    You can use this function to get information about the nodes in the cluster.\n    The MemberInfo objects returned can give information like the state of the node\n    (Initializing, Leader, ...), the instance id, is_alive, and the endpoint of\n    the node (address, port).\n    Args:\n        uri: the URI that will be used to connect to the node.\n        credentials: the ChannelCredentials to use to connect to the node.\n    Returns:\n        The nodes information as gossip_pb2.MemberInfo objects.\n    \"\"\"\nwith grpc.secure_channel(uri, credentials) as channel:\nstub = gossip_pb2_grpc.GossipStub(channel)\ninfo = gossip.read(stub)\nreturn info.members\n</code></pre>"},{"location":"reference/eventstore_grpc/event_data/","title":"Event data","text":"<p>An Event.</p>"},{"location":"reference/eventstore_grpc/event_data/#eventstore_grpc.event_data.EventData","title":"<code>EventData</code>","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Events abstract class.</p> <p>When appending events to EventStoreDB they must first all be wrapped in an Event object. This allow you to specify the content of the event, the type of event and whether its in JSON format. In it's simplest form you need to three following arguments.</p> <ul> <li><code>event_id</code>: this takes the format of <code>Uuid</code> and is used to uniquely identify the     event your are trying to append. If two events with the same <code>Uuid</code> are appended     to the same stream in quick succession, EventStoreDB will only append one copy     of the event to the stream.</li> <li><code>type</code>: an event type should be supplied for each event. This is a unique string     used to identify the type of event you are saving.     It is common to see the explicit event code type name used as the type as     it makes serializing and de-serializing of the event easy. However we recommend     against this as it couples the storage to the type and will make it more     difficult if you need to version the event at a later date.</li> <li><code>data</code>: representation of your event data. It is recommended that you store your     events as JSON objects as this will allow you to make use of all of     EventStoreDB's functionality such as projections. Ultimately though, you can     save it using whatever format you like as eventually, it will be stored as     encoded bytes.</li> <li><code>metadata</code>: it is common to need to store additional information along side your     event that is part of the event itself. This can be correlation Id's,     timestamps, access information, etc. EventStoreDB allows you to store a     separate byte array containing this information to keep it separate.</li> <li><code>is_json</code>: a simple boolean field to tell EventStoreDB if the event is stored as     a json, <code>True</code> by default.</li> </ul> Source code in <code>src/eventstore_grpc/event_data.py</code> <pre><code>class EventData(abc.ABC):\n\"\"\"Events abstract class.\n    When appending events to EventStoreDB they must first all be wrapped in an Event\n    object. This allow you to specify the content of the event, the type of event\n    and whether its in JSON format. In it's simplest form you need to three following\n    arguments.\n    * `event_id`: this takes the format of `Uuid` and is used to uniquely identify the\n        event your are trying to append. If two events with the same `Uuid` are appended\n        to the same stream in quick succession, EventStoreDB will only append one copy\n        of the event to the stream.\n    * `type`: an event type should be supplied for each event. This is a unique string\n        used to identify the type of event you are saving.\n        It is common to see the explicit event code type name used as the type as\n        it makes serializing and de-serializing of the event easy. However we recommend\n        against this as it couples the storage to the type and will make it more\n        difficult if you need to version the event at a later date.\n    * `data`: representation of your event data. It is recommended that you store your\n        events as JSON objects as this will allow you to make use of all of\n        EventStoreDB's functionality such as projections. Ultimately though, you can\n        save it using whatever format you like as eventually, it will be stored as\n        encoded bytes.\n    * `metadata`: it is common to need to store additional information along side your\n        event that is part of the event itself. This can be correlation Id's,\n        timestamps, access information, etc. EventStoreDB allows you to store a\n        separate byte array containing this information to keep it separate.\n    * `is_json`: a simple boolean field to tell EventStoreDB if the event is stored as\n        a json, `True` by default.\n    \"\"\"\ndef __init__(\nself,\nevent_id: uuid.UUID,\ntype: str,\ndata: Any,\nmetadata: Any,\nis_json: bool = True,\n):\nself.event_id = event_id\nself.type = type\nself.data = data\nself.metadata = metadata\nself.is_json = is_json\ndef __repr__(self):\nreturn f\"{self.__class__.__name__}(**{self.__dict__!r})\"  # pragma: nocover\ndef __str__(self):\nreturn f\"{self.type} =&gt; {self.data}\"  # pragma: nocover\n@staticmethod\ndef _validate_event_id(event_id: Any) -&gt; uuid.UUID:\nif not isinstance(event_id, uuid.UUID):\nreturn uuid.UUID(str(event_id))  # raises ValueError\nreturn event_id\n@property\ndef event_id(self) -&gt; uuid.UUID:\nreturn self._event_id\n@event_id.setter\ndef event_id(self, value: Any) -&gt; None:\nself._event_id = self._validate_event_id(value)\n@property\ndef data_content_type(self):\nreturn \"application/json\" if self.is_json else \"application/octet-stream\"\n@property\ndef serialized_metadata(self):\nreturn json.dumps(self.metadata).encode()\n@property\n@abc.abstractmethod\ndef serialized_data(self):\nraise NotImplementedError  # pragma: nocover\n@classmethod\n@abc.abstractmethod\ndef deserialize_data(cls, data: str):\nraise NotImplementedError  # pragma: nocover\n</code></pre>"},{"location":"reference/eventstore_grpc/event_data/#eventstore_grpc.event_data.JSONEventData","title":"<code>JSONEventData</code>","text":"<p>         Bases: <code>EventData</code></p> <p>An Event carrying data as a JSON payload.</p> Source code in <code>src/eventstore_grpc/event_data.py</code> <pre><code>class JSONEventData(EventData):\n\"\"\"An Event carrying data as a JSON payload.\"\"\"\ndef __init__(\nself,\ntype: str,\ndata: Dict,  # TODO: should be JSON-able.\nmetadata: Any = None,\nevent_id: uuid.UUID = None,\n):\nif event_id is None:\nevent_id = uuid.uuid4()\nif metadata is None:\nmetadata = {}\nsuper().__init__(event_id, type, data, metadata, True)\n@property\ndef serialized_data(self):\nreturn json.dumps(self.data).encode()\n@classmethod\ndef deserialize_data(cls, data: str):\nreturn json.loads(data)\n</code></pre>"},{"location":"reference/eventstore_grpc/client/__init__/","title":"init","text":""},{"location":"reference/eventstore_grpc/client/event_store/","title":"Event store","text":""},{"location":"reference/eventstore_grpc/client/event_store/#eventstore_grpc.client.event_store.EventStore","title":"<code>EventStore</code>","text":"<p>         Bases: <code>ClientBase</code></p> <p>EventStore Client.</p> Source code in <code>src/eventstore_grpc/client/event_store.py</code> <pre><code>class EventStore(ClientBase):\n\"\"\"EventStore Client.\"\"\"\ndef __init__(\nself,\nhosts: Union[str, list[str]],\ndiscover: Optional[bool] = None,  # TODO: maybe remove?\ntls: Optional[bool] = None,  # TODO: maybe remove and keep just tls_ca_file.\nkeep_alive_interval: Optional[int] = None,  # TODO: do we need this?\nkeep_alive_timeout: Optional[int] = None,  # TODO: do we need this?\nusername: Optional[str] = None,\npassword: Optional[str] = None,\ntls_ca_file: Optional[str] = None,\n) -&gt; None:\n\"\"\"Initializes a new EventStore Client.\n        Args:\n            hosts: either a single host url, or multiple ones, as a list.\n            discover: whether or not to use discovery.\n            tls: whether or not to use tls encryption.\n            keep_alive_interval: the number of seconds for the keep alive interval.\n            keep_alive_timeout: the number of seconds for the keep alive timeout.\n            username: the username.\n            password: the password.\n            tls_ca_file: the filepath to the certificate to use for tls encryption.\n        Raises:\n            ValueError: when something goes wrong with the values you passed.\n        \"\"\"\nif not any([keep_alive_interval, keep_alive_timeout]):\nkeep_alive = None\nelse:\nkeep_alive = KeepAlive()\nif keep_alive_interval:\nkeep_alive.interval = keep_alive_interval\nif keep_alive_timeout:\nkeep_alive.timeout = keep_alive_timeout\nif not tls and tls_ca_file:\nraise ValueError(f\"tls is {tls} but you specified a ca_file: {tls_ca_file}\")\nif any([username, password]) and not all([username, password]):\nraise ValueError(\n\"You must specify both username AND password, or none of them.\"\n)\nsuper().__init__(\nTransport(\nhosts=hosts,\ndiscover=discover,\ntls=tls,\nkeep_alive=keep_alive,\nauth=Auth(\nroot_certificate=tls_ca_file, username=username, password=password\n),\n)\n)\nself.gossip = Gossip(self._transport)\nself.operations = Operations(self._transport)\nself.persistent = Persistent(self._transport)\nself.projections = Projections(self._transport)\nself.subscriptions = Subscriptions(self._transport)\nself.streams = Streams(self._transport)\nif self._transport.tls:  # TODO: is this the right condition?\nself.users = Users(self._transport)\n</code></pre>"},{"location":"reference/eventstore_grpc/client/event_store/#eventstore_grpc.client.event_store.EventStore.__init__","title":"<code>__init__(hosts, discover=None, tls=None, keep_alive_interval=None, keep_alive_timeout=None, username=None, password=None, tls_ca_file=None)</code>","text":"<p>Initializes a new EventStore Client.</p> <p>Parameters:</p> Name Type Description Default <code>hosts</code> <code>Union[str, list[str]]</code> <p>either a single host url, or multiple ones, as a list.</p> required <code>discover</code> <code>Optional[bool]</code> <p>whether or not to use discovery.</p> <code>None</code> <code>tls</code> <code>Optional[bool]</code> <p>whether or not to use tls encryption.</p> <code>None</code> <code>keep_alive_interval</code> <code>Optional[int]</code> <p>the number of seconds for the keep alive interval.</p> <code>None</code> <code>keep_alive_timeout</code> <code>Optional[int]</code> <p>the number of seconds for the keep alive timeout.</p> <code>None</code> <code>username</code> <code>Optional[str]</code> <p>the username.</p> <code>None</code> <code>password</code> <code>Optional[str]</code> <p>the password.</p> <code>None</code> <code>tls_ca_file</code> <code>Optional[str]</code> <p>the filepath to the certificate to use for tls encryption.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>when something goes wrong with the values you passed.</p> Source code in <code>src/eventstore_grpc/client/event_store.py</code> <pre><code>def __init__(\nself,\nhosts: Union[str, list[str]],\ndiscover: Optional[bool] = None,  # TODO: maybe remove?\ntls: Optional[bool] = None,  # TODO: maybe remove and keep just tls_ca_file.\nkeep_alive_interval: Optional[int] = None,  # TODO: do we need this?\nkeep_alive_timeout: Optional[int] = None,  # TODO: do we need this?\nusername: Optional[str] = None,\npassword: Optional[str] = None,\ntls_ca_file: Optional[str] = None,\n) -&gt; None:\n\"\"\"Initializes a new EventStore Client.\n    Args:\n        hosts: either a single host url, or multiple ones, as a list.\n        discover: whether or not to use discovery.\n        tls: whether or not to use tls encryption.\n        keep_alive_interval: the number of seconds for the keep alive interval.\n        keep_alive_timeout: the number of seconds for the keep alive timeout.\n        username: the username.\n        password: the password.\n        tls_ca_file: the filepath to the certificate to use for tls encryption.\n    Raises:\n        ValueError: when something goes wrong with the values you passed.\n    \"\"\"\nif not any([keep_alive_interval, keep_alive_timeout]):\nkeep_alive = None\nelse:\nkeep_alive = KeepAlive()\nif keep_alive_interval:\nkeep_alive.interval = keep_alive_interval\nif keep_alive_timeout:\nkeep_alive.timeout = keep_alive_timeout\nif not tls and tls_ca_file:\nraise ValueError(f\"tls is {tls} but you specified a ca_file: {tls_ca_file}\")\nif any([username, password]) and not all([username, password]):\nraise ValueError(\n\"You must specify both username AND password, or none of them.\"\n)\nsuper().__init__(\nTransport(\nhosts=hosts,\ndiscover=discover,\ntls=tls,\nkeep_alive=keep_alive,\nauth=Auth(\nroot_certificate=tls_ca_file, username=username, password=password\n),\n)\n)\nself.gossip = Gossip(self._transport)\nself.operations = Operations(self._transport)\nself.persistent = Persistent(self._transport)\nself.projections = Projections(self._transport)\nself.subscriptions = Subscriptions(self._transport)\nself.streams = Streams(self._transport)\nif self._transport.tls:  # TODO: is this the right condition?\nself.users = Users(self._transport)\n</code></pre>"},{"location":"reference/eventstore_grpc/client/gossip/","title":"Gossip","text":"<p>Gossip Mixins.</p>"},{"location":"reference/eventstore_grpc/client/gossip/#eventstore_grpc.client.gossip.Gossip","title":"<code>Gossip</code>","text":"<p>         Bases: <code>ClientBase</code></p> <p>Handles Gossip Operations.</p> Source code in <code>src/eventstore_grpc/client/gossip.py</code> <pre><code>class Gossip(ClientBase):\n\"\"\"Handles Gossip Operations.\"\"\"\ndef get_cluster_info(self, **kwargs) -&gt; ClusterInfo:\n\"\"\"Gets cluster info.\"\"\"\nstub = gossip_pb2_grpc.GossipStub(self.channel)\nresult = gossip.read(stub, **kwargs)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/gossip/#eventstore_grpc.client.gossip.Gossip.get_cluster_info","title":"<code>get_cluster_info(**kwargs)</code>","text":"<p>Gets cluster info.</p> Source code in <code>src/eventstore_grpc/client/gossip.py</code> <pre><code>def get_cluster_info(self, **kwargs) -&gt; ClusterInfo:\n\"\"\"Gets cluster info.\"\"\"\nstub = gossip_pb2_grpc.GossipStub(self.channel)\nresult = gossip.read(stub, **kwargs)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/operations/","title":"Operations","text":"<p>Operations Mixins.</p>"},{"location":"reference/eventstore_grpc/client/operations/#eventstore_grpc.client.operations.Operations","title":"<code>Operations</code>","text":"<p>         Bases: <code>ClientBase</code></p> <p>Handles Operations.</p> Source code in <code>src/eventstore_grpc/client/operations.py</code> <pre><code>class Operations(ClientBase):\n\"\"\"Handles Operations.\"\"\"\ndef merge_indexes(self, **kwargs) -&gt; shared_pb2.Empty:\n\"\"\"Merges indexes.\"\"\"\nstub = operations_pb2_grpc.OperationsStub(self.channel)\nresult = operations.merge_indexes(stub, **kwargs)\nreturn result\ndef resign_node(self, **kwargs) -&gt; shared_pb2.Empty:\n\"\"\"Resigns node.\"\"\"\nstub = operations_pb2_grpc.OperationsStub(self.channel)\nresult = operations.resign_node(stub, **kwargs)\nreturn result\ndef restart_persistent_subscriptions(self, **kwargs) -&gt; shared_pb2.Empty:\n\"\"\"Restarts persistent subscriptions.\"\"\"\nstub = operations_pb2_grpc.OperationsStub(self.channel)\nresult = operations.restart_persistent_subscriptions(stub, **kwargs)\nreturn result\ndef set_node_priority(self, priority: int, **kwargs) -&gt; shared_pb2.Empty:\n\"\"\"Sets node priority.\n        Args:\n            priority: the priority level for the node you're currently connected to.\n        \"\"\"\nstub = operations_pb2_grpc.OperationsStub(self.channel)\nresult = operations.set_node_priority(stub, priority, **kwargs)\nreturn result\ndef shutdown(self, **kwargs) -&gt; shared_pb2.Empty:\n\"\"\"Shuts the node down.\"\"\"\nstub = operations_pb2_grpc.OperationsStub(self.channel)\nresult = operations.shutdown(stub, **kwargs)\nreturn result\ndef start_scavenge(\nself, thread_count: int, start_from_chunk: int, **kwargs\n) -&gt; operations_pb2.ScavengeResp:\n\"\"\"Starts a scavenge operation.\"\"\"\nstub = operations_pb2_grpc.OperationsStub(self.channel)\nresult = operations.start_scavenge(\nstub, thread_count=thread_count, start_from_chunk=start_from_chunk, **kwargs\n)\nreturn result\ndef stop_scavenge(self, scavenge_id: str, **kwargs) -&gt; operations_pb2.ScavengeResp:\n\"\"\"Stops a scavenge operation.\"\"\"\nstub = operations_pb2_grpc.OperationsStub(self.channel)\nresult = operations.stop_scavenge(stub, scavenge_id=scavenge_id, **kwargs)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/operations/#eventstore_grpc.client.operations.Operations.merge_indexes","title":"<code>merge_indexes(**kwargs)</code>","text":"<p>Merges indexes.</p> Source code in <code>src/eventstore_grpc/client/operations.py</code> <pre><code>def merge_indexes(self, **kwargs) -&gt; shared_pb2.Empty:\n\"\"\"Merges indexes.\"\"\"\nstub = operations_pb2_grpc.OperationsStub(self.channel)\nresult = operations.merge_indexes(stub, **kwargs)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/operations/#eventstore_grpc.client.operations.Operations.resign_node","title":"<code>resign_node(**kwargs)</code>","text":"<p>Resigns node.</p> Source code in <code>src/eventstore_grpc/client/operations.py</code> <pre><code>def resign_node(self, **kwargs) -&gt; shared_pb2.Empty:\n\"\"\"Resigns node.\"\"\"\nstub = operations_pb2_grpc.OperationsStub(self.channel)\nresult = operations.resign_node(stub, **kwargs)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/operations/#eventstore_grpc.client.operations.Operations.restart_persistent_subscriptions","title":"<code>restart_persistent_subscriptions(**kwargs)</code>","text":"<p>Restarts persistent subscriptions.</p> Source code in <code>src/eventstore_grpc/client/operations.py</code> <pre><code>def restart_persistent_subscriptions(self, **kwargs) -&gt; shared_pb2.Empty:\n\"\"\"Restarts persistent subscriptions.\"\"\"\nstub = operations_pb2_grpc.OperationsStub(self.channel)\nresult = operations.restart_persistent_subscriptions(stub, **kwargs)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/operations/#eventstore_grpc.client.operations.Operations.set_node_priority","title":"<code>set_node_priority(priority, **kwargs)</code>","text":"<p>Sets node priority.</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>the priority level for the node you're currently connected to.</p> required Source code in <code>src/eventstore_grpc/client/operations.py</code> <pre><code>def set_node_priority(self, priority: int, **kwargs) -&gt; shared_pb2.Empty:\n\"\"\"Sets node priority.\n    Args:\n        priority: the priority level for the node you're currently connected to.\n    \"\"\"\nstub = operations_pb2_grpc.OperationsStub(self.channel)\nresult = operations.set_node_priority(stub, priority, **kwargs)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/operations/#eventstore_grpc.client.operations.Operations.shutdown","title":"<code>shutdown(**kwargs)</code>","text":"<p>Shuts the node down.</p> Source code in <code>src/eventstore_grpc/client/operations.py</code> <pre><code>def shutdown(self, **kwargs) -&gt; shared_pb2.Empty:\n\"\"\"Shuts the node down.\"\"\"\nstub = operations_pb2_grpc.OperationsStub(self.channel)\nresult = operations.shutdown(stub, **kwargs)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/operations/#eventstore_grpc.client.operations.Operations.start_scavenge","title":"<code>start_scavenge(thread_count, start_from_chunk, **kwargs)</code>","text":"<p>Starts a scavenge operation.</p> Source code in <code>src/eventstore_grpc/client/operations.py</code> <pre><code>def start_scavenge(\nself, thread_count: int, start_from_chunk: int, **kwargs\n) -&gt; operations_pb2.ScavengeResp:\n\"\"\"Starts a scavenge operation.\"\"\"\nstub = operations_pb2_grpc.OperationsStub(self.channel)\nresult = operations.start_scavenge(\nstub, thread_count=thread_count, start_from_chunk=start_from_chunk, **kwargs\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/operations/#eventstore_grpc.client.operations.Operations.stop_scavenge","title":"<code>stop_scavenge(scavenge_id, **kwargs)</code>","text":"<p>Stops a scavenge operation.</p> Source code in <code>src/eventstore_grpc/client/operations.py</code> <pre><code>def stop_scavenge(self, scavenge_id: str, **kwargs) -&gt; operations_pb2.ScavengeResp:\n\"\"\"Stops a scavenge operation.\"\"\"\nstub = operations_pb2_grpc.OperationsStub(self.channel)\nresult = operations.stop_scavenge(stub, scavenge_id=scavenge_id, **kwargs)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/persistent/","title":"Persistent","text":"<p>Persistents Mixin.</p>"},{"location":"reference/eventstore_grpc/client/persistent/#eventstore_grpc.client.persistent.Persistent","title":"<code>Persistent</code>","text":"<p>         Bases: <code>ClientBase</code></p> <p>Handles Persistent operations.</p> Source code in <code>src/eventstore_grpc/client/persistent.py</code> <pre><code>class Persistent(ClientBase):\n\"\"\"Handles Persistent operations.\"\"\"\ndef create_persistent_subscription(\nself,\ngroup_name: str = None,\nstream: Optional[str] = None,\nresolve_link_to_s: bool = False,\nfrom_revision: Union[int, str] = END,\ncommit_position: Optional[int] = None,\nprepare_position: Optional[int] = None,\nextra_statistics: bool = False,\nmessage_timeout_ms: int = 30000,\ncheckpoint_after_ms: int = 2000,\nmax_retry_count: int = 10,\nmin_checkpoint_count: int = 10,\nmax_checkpoint_count: int = 1000,\nmax_subscriber_count: int = 0,\nlive_buffer_size: int = 500,\nhistory_buffer_size: int = 500,\nread_batch_size: int = 20,\nstrategy: str = ROUND_ROBIN,\nfilter_options: Optional[\npersistent_pb2.CreateReq.AllOptions.FilterOptions\n] = None,\n**kwargs\n) -&gt; persistent_pb2.CreateResp:\n\"\"\"Creates a new persistent subscription.\n        Args:\n            group_name: a group name for the subscription that will be created.\n            stream: the name of the stream. A persistent subscription to the `$all`\n                    stream will be created if this value is left to `None`.\n            resolve_link_to_s: whether or not to resolve events links to actual events.\n            from_revision: the subscription will start from the revision specified here.\n            extra_statistics: whether to track latency statistics on this subscription.\n            message_timeout_ms: the amount of time after which to consider a message as\n                                timed out and retried.\n            checkpoint_after_ms: the amount of time to try to checkpoint after.\n            max_retry_count: the maximum number of retries (due to timeout) before a\n                             message is considered to be parked.\n            min_checkpoint_count: The minimum number of messages to process before a\n                                  checkpoint may be written.\n            max_checkpoint_count: The maximum number of messages not checkpointed\n                                  before forcing a checkpoint.\n            max_subscriber_count: The maximum number of subscribers allowed.\n            live_buffer_size: the size of the buffer (in-memory) listening to live\n                              messages as they happen before pagin occurs.\n            history_buffer_size: The number of events to cache when paging through\n                                 history.\n            read_batch_size: The number of events read at a time when paging through history.\n            strategy: the strategy that will be used to send events to the subscribers\n                      of the same group.\n            filter_options: an optional FilterOptions instance to use to filter events\n                            in the persistent subscription.\n        Returns:\n            A persistent_pb.CreateResp\n        \"\"\"\nstub = persistent_pb2_grpc.PersistentSubscriptionsStub(self.channel)\nresult = persistent.create_persistent_subscription(\nstub=stub,\nstream=stream,\ngroup_name=group_name,\nresolve_link_to_s=resolve_link_to_s,\nfrom_revision=from_revision,\ncommit_position=commit_position,\nprepare_position=prepare_position,\nextra_statistics=extra_statistics,\nmessage_timeout_ms=message_timeout_ms,\ncheckpoint_after_ms=checkpoint_after_ms,\nmax_retry_count=max_retry_count,\nmin_checkpoint_count=min_checkpoint_count,\nmax_checkpoint_count=max_checkpoint_count,\nmax_subscriber_count=max_subscriber_count,\nlive_buffer_size=live_buffer_size,\nhistory_buffer_size=history_buffer_size,\nread_batch_size=read_batch_size,\nstrategy=strategy,\nfilter_options=filter_options,\n**kwargs,\n)\nreturn result\ndef update_persistent_subscription(\nself,\ngroup_name: Optional[str] = None,\nstream: Optional[str] = None,\nresolve_link_to_s: Optional[bool] = None,\nfrom_revision: Optional[Union[int, str]] = None,\ncommit_position: Optional[int] = None,\nprepare_position: Optional[int] = None,\nextra_statistics: Optional[bool] = None,\nmessage_timeout_ms: Optional[int] = None,\ncheckpoint_after_ms: Optional[int] = None,\nmax_retry_count: Optional[int] = None,\nmin_checkpoint_count: Optional[int] = None,\nmax_checkpoint_count: Optional[int] = None,\nmax_subscriber_count: Optional[int] = None,\nlive_buffer_size: Optional[int] = None,\nhistory_buffer_size: Optional[int] = None,\nread_batch_size: Optional[int] = None,\nstrategy: Optional[str] = None,\n**kwargs\n) -&gt; persistent_pb2.UpdateResp:\n\"\"\"Updates a persistent subscription.\"\"\"\nstub = persistent_pb2_grpc.PersistentSubscriptionsStub(self.channel)\nresult = persistent.update_persistent_subscription(\nstub=stub,\ngroup_name=group_name,\nstream=stream,\nresolve_link_to_s=resolve_link_to_s,\nfrom_revision=from_revision,\ncommit_position=commit_position,\nprepare_position=prepare_position,\nextra_statistics=extra_statistics,\nmessage_timeout_ms=message_timeout_ms,\ncheckpoint_after_ms=checkpoint_after_ms,\nmax_retry_count=max_retry_count,\nmin_checkpoint_count=min_checkpoint_count,\nmax_checkpoint_count=max_checkpoint_count,\nmax_subscriber_count=max_subscriber_count,\nlive_buffer_size=live_buffer_size,\nhistory_buffer_size=history_buffer_size,\nread_batch_size=read_batch_size,\nnamed_consumer_strategy=strategy,\n**kwargs,\n)\nreturn result\ndef delete_persistent_subscription(\nself,\ngroup: str,\nstream: Optional[str] = None,\n) -&gt; persistent_pb2.DeleteResp:\nstub = persistent_pb2_grpc.PersistentSubscriptionsStub(self.channel)\nresult = persistent.delete_persistent_subscription(\nstub=stub, stream=stream, group=group\n)\nreturn result\ndef get_info(\nself,\ngroup_name: str,\nstream_name: Optional[str] = None,\n) -&gt; persistent_pb2.GetInfoResp:\n\"\"\"Get info about a persistent subscription.\n        Args:\n            group_name: a group name to get info about.\n            stream_name: the name of the stream, or None if it's some $all persistent\n                         subscription.\n        \"\"\"\nstub = persistent_pb2_grpc.PersistentSubscriptionsStub(self.channel)\nresult = persistent.get_info(\nstub=stub, group_name=group_name, stream_name=stream_name\n)\nreturn result\ndef replay_parked(\nself,\ngroup_name: str,\nstream_name: Optional[str] = None,\nstop_at: Optional[int] = None,\n) -&gt; persistent_pb2.ReplayParkedResp:\n\"\"\"Replays parked events.\n        Args:\n            group_name: the group name.\n            stream_name: the name of the stream, or None for $all.\n            stop_at: the postition at which to stop.\n        \"\"\"\nstub = persistent_pb2_grpc.PersistentSubscriptionsStub(self.channel)\nresult = persistent.replay_parked(\nstub=stub, group_name=group_name, stream_name=stream_name, stop_at=stop_at\n)\nreturn result\ndef list_persistent(\nself,\nstream_name: Optional[str] = None,\nlist_all: bool = False,\n) -&gt; persistent_pb2.ListResp:\n\"\"\"List persistent subscriptions.\n        Args:\n            stream_name: the name of the stream.\n            list_all: whether to list all the persistent subscriptions available.\n        \"\"\"\nstub = persistent_pb2_grpc.PersistentSubscriptionsStub(self.channel)\nresults = persistent.list_persistent(\nstub=stub, stream_name=stream_name, list_all=True\n)\nreturn results\n</code></pre>"},{"location":"reference/eventstore_grpc/client/persistent/#eventstore_grpc.client.persistent.Persistent.create_persistent_subscription","title":"<code>create_persistent_subscription(group_name=None, stream=None, resolve_link_to_s=False, from_revision=END, commit_position=None, prepare_position=None, extra_statistics=False, message_timeout_ms=30000, checkpoint_after_ms=2000, max_retry_count=10, min_checkpoint_count=10, max_checkpoint_count=1000, max_subscriber_count=0, live_buffer_size=500, history_buffer_size=500, read_batch_size=20, strategy=ROUND_ROBIN, filter_options=None, **kwargs)</code>","text":"<p>Creates a new persistent subscription.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>a group name for the subscription that will be created.</p> <code>None</code> <code>stream</code> <code>Optional[str]</code> <p>the name of the stream. A persistent subscription to the <code>$all</code>     stream will be created if this value is left to <code>None</code>.</p> <code>None</code> <code>resolve_link_to_s</code> <code>bool</code> <p>whether or not to resolve events links to actual events.</p> <code>False</code> <code>from_revision</code> <code>Union[int, str]</code> <p>the subscription will start from the revision specified here.</p> <code>END</code> <code>extra_statistics</code> <code>bool</code> <p>whether to track latency statistics on this subscription.</p> <code>False</code> <code>message_timeout_ms</code> <code>int</code> <p>the amount of time after which to consider a message as                 timed out and retried.</p> <code>30000</code> <code>checkpoint_after_ms</code> <code>int</code> <p>the amount of time to try to checkpoint after.</p> <code>2000</code> <code>max_retry_count</code> <code>int</code> <p>the maximum number of retries (due to timeout) before a              message is considered to be parked.</p> <code>10</code> <code>min_checkpoint_count</code> <code>int</code> <p>The minimum number of messages to process before a                   checkpoint may be written.</p> <code>10</code> <code>max_checkpoint_count</code> <code>int</code> <p>The maximum number of messages not checkpointed                   before forcing a checkpoint.</p> <code>1000</code> <code>max_subscriber_count</code> <code>int</code> <p>The maximum number of subscribers allowed.</p> <code>0</code> <code>live_buffer_size</code> <code>int</code> <p>the size of the buffer (in-memory) listening to live               messages as they happen before pagin occurs.</p> <code>500</code> <code>history_buffer_size</code> <code>int</code> <p>The number of events to cache when paging through                  history.</p> <code>500</code> <code>read_batch_size</code> <code>int</code> <p>The number of events read at a time when paging through history.</p> <code>20</code> <code>strategy</code> <code>str</code> <p>the strategy that will be used to send events to the subscribers       of the same group.</p> <code>ROUND_ROBIN</code> <code>filter_options</code> <code>Optional[persistent_pb2.CreateReq.AllOptions.FilterOptions]</code> <p>an optional FilterOptions instance to use to filter events             in the persistent subscription.</p> <code>None</code> <p>Returns:</p> Type Description <code>persistent_pb2.CreateResp</code> <p>A persistent_pb.CreateResp</p> Source code in <code>src/eventstore_grpc/client/persistent.py</code> <pre><code>def create_persistent_subscription(\nself,\ngroup_name: str = None,\nstream: Optional[str] = None,\nresolve_link_to_s: bool = False,\nfrom_revision: Union[int, str] = END,\ncommit_position: Optional[int] = None,\nprepare_position: Optional[int] = None,\nextra_statistics: bool = False,\nmessage_timeout_ms: int = 30000,\ncheckpoint_after_ms: int = 2000,\nmax_retry_count: int = 10,\nmin_checkpoint_count: int = 10,\nmax_checkpoint_count: int = 1000,\nmax_subscriber_count: int = 0,\nlive_buffer_size: int = 500,\nhistory_buffer_size: int = 500,\nread_batch_size: int = 20,\nstrategy: str = ROUND_ROBIN,\nfilter_options: Optional[\npersistent_pb2.CreateReq.AllOptions.FilterOptions\n] = None,\n**kwargs\n) -&gt; persistent_pb2.CreateResp:\n\"\"\"Creates a new persistent subscription.\n    Args:\n        group_name: a group name for the subscription that will be created.\n        stream: the name of the stream. A persistent subscription to the `$all`\n                stream will be created if this value is left to `None`.\n        resolve_link_to_s: whether or not to resolve events links to actual events.\n        from_revision: the subscription will start from the revision specified here.\n        extra_statistics: whether to track latency statistics on this subscription.\n        message_timeout_ms: the amount of time after which to consider a message as\n                            timed out and retried.\n        checkpoint_after_ms: the amount of time to try to checkpoint after.\n        max_retry_count: the maximum number of retries (due to timeout) before a\n                         message is considered to be parked.\n        min_checkpoint_count: The minimum number of messages to process before a\n                              checkpoint may be written.\n        max_checkpoint_count: The maximum number of messages not checkpointed\n                              before forcing a checkpoint.\n        max_subscriber_count: The maximum number of subscribers allowed.\n        live_buffer_size: the size of the buffer (in-memory) listening to live\n                          messages as they happen before pagin occurs.\n        history_buffer_size: The number of events to cache when paging through\n                             history.\n        read_batch_size: The number of events read at a time when paging through history.\n        strategy: the strategy that will be used to send events to the subscribers\n                  of the same group.\n        filter_options: an optional FilterOptions instance to use to filter events\n                        in the persistent subscription.\n    Returns:\n        A persistent_pb.CreateResp\n    \"\"\"\nstub = persistent_pb2_grpc.PersistentSubscriptionsStub(self.channel)\nresult = persistent.create_persistent_subscription(\nstub=stub,\nstream=stream,\ngroup_name=group_name,\nresolve_link_to_s=resolve_link_to_s,\nfrom_revision=from_revision,\ncommit_position=commit_position,\nprepare_position=prepare_position,\nextra_statistics=extra_statistics,\nmessage_timeout_ms=message_timeout_ms,\ncheckpoint_after_ms=checkpoint_after_ms,\nmax_retry_count=max_retry_count,\nmin_checkpoint_count=min_checkpoint_count,\nmax_checkpoint_count=max_checkpoint_count,\nmax_subscriber_count=max_subscriber_count,\nlive_buffer_size=live_buffer_size,\nhistory_buffer_size=history_buffer_size,\nread_batch_size=read_batch_size,\nstrategy=strategy,\nfilter_options=filter_options,\n**kwargs,\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/persistent/#eventstore_grpc.client.persistent.Persistent.get_info","title":"<code>get_info(group_name, stream_name=None)</code>","text":"<p>Get info about a persistent subscription.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>a group name to get info about.</p> required <code>stream_name</code> <code>Optional[str]</code> <p>the name of the stream, or None if it's some $all persistent          subscription.</p> <code>None</code> Source code in <code>src/eventstore_grpc/client/persistent.py</code> <pre><code>def get_info(\nself,\ngroup_name: str,\nstream_name: Optional[str] = None,\n) -&gt; persistent_pb2.GetInfoResp:\n\"\"\"Get info about a persistent subscription.\n    Args:\n        group_name: a group name to get info about.\n        stream_name: the name of the stream, or None if it's some $all persistent\n                     subscription.\n    \"\"\"\nstub = persistent_pb2_grpc.PersistentSubscriptionsStub(self.channel)\nresult = persistent.get_info(\nstub=stub, group_name=group_name, stream_name=stream_name\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/persistent/#eventstore_grpc.client.persistent.Persistent.list_persistent","title":"<code>list_persistent(stream_name=None, list_all=False)</code>","text":"<p>List persistent subscriptions.</p> <p>Parameters:</p> Name Type Description Default <code>stream_name</code> <code>Optional[str]</code> <p>the name of the stream.</p> <code>None</code> <code>list_all</code> <code>bool</code> <p>whether to list all the persistent subscriptions available.</p> <code>False</code> Source code in <code>src/eventstore_grpc/client/persistent.py</code> <pre><code>def list_persistent(\nself,\nstream_name: Optional[str] = None,\nlist_all: bool = False,\n) -&gt; persistent_pb2.ListResp:\n\"\"\"List persistent subscriptions.\n    Args:\n        stream_name: the name of the stream.\n        list_all: whether to list all the persistent subscriptions available.\n    \"\"\"\nstub = persistent_pb2_grpc.PersistentSubscriptionsStub(self.channel)\nresults = persistent.list_persistent(\nstub=stub, stream_name=stream_name, list_all=True\n)\nreturn results\n</code></pre>"},{"location":"reference/eventstore_grpc/client/persistent/#eventstore_grpc.client.persistent.Persistent.replay_parked","title":"<code>replay_parked(group_name, stream_name=None, stop_at=None)</code>","text":"<p>Replays parked events.</p> <p>Parameters:</p> Name Type Description Default <code>group_name</code> <code>str</code> <p>the group name.</p> required <code>stream_name</code> <code>Optional[str]</code> <p>the name of the stream, or None for $all.</p> <code>None</code> <code>stop_at</code> <code>Optional[int]</code> <p>the postition at which to stop.</p> <code>None</code> Source code in <code>src/eventstore_grpc/client/persistent.py</code> <pre><code>def replay_parked(\nself,\ngroup_name: str,\nstream_name: Optional[str] = None,\nstop_at: Optional[int] = None,\n) -&gt; persistent_pb2.ReplayParkedResp:\n\"\"\"Replays parked events.\n    Args:\n        group_name: the group name.\n        stream_name: the name of the stream, or None for $all.\n        stop_at: the postition at which to stop.\n    \"\"\"\nstub = persistent_pb2_grpc.PersistentSubscriptionsStub(self.channel)\nresult = persistent.replay_parked(\nstub=stub, group_name=group_name, stream_name=stream_name, stop_at=stop_at\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/persistent/#eventstore_grpc.client.persistent.Persistent.update_persistent_subscription","title":"<code>update_persistent_subscription(group_name=None, stream=None, resolve_link_to_s=None, from_revision=None, commit_position=None, prepare_position=None, extra_statistics=None, message_timeout_ms=None, checkpoint_after_ms=None, max_retry_count=None, min_checkpoint_count=None, max_checkpoint_count=None, max_subscriber_count=None, live_buffer_size=None, history_buffer_size=None, read_batch_size=None, strategy=None, **kwargs)</code>","text":"<p>Updates a persistent subscription.</p> Source code in <code>src/eventstore_grpc/client/persistent.py</code> <pre><code>def update_persistent_subscription(\nself,\ngroup_name: Optional[str] = None,\nstream: Optional[str] = None,\nresolve_link_to_s: Optional[bool] = None,\nfrom_revision: Optional[Union[int, str]] = None,\ncommit_position: Optional[int] = None,\nprepare_position: Optional[int] = None,\nextra_statistics: Optional[bool] = None,\nmessage_timeout_ms: Optional[int] = None,\ncheckpoint_after_ms: Optional[int] = None,\nmax_retry_count: Optional[int] = None,\nmin_checkpoint_count: Optional[int] = None,\nmax_checkpoint_count: Optional[int] = None,\nmax_subscriber_count: Optional[int] = None,\nlive_buffer_size: Optional[int] = None,\nhistory_buffer_size: Optional[int] = None,\nread_batch_size: Optional[int] = None,\nstrategy: Optional[str] = None,\n**kwargs\n) -&gt; persistent_pb2.UpdateResp:\n\"\"\"Updates a persistent subscription.\"\"\"\nstub = persistent_pb2_grpc.PersistentSubscriptionsStub(self.channel)\nresult = persistent.update_persistent_subscription(\nstub=stub,\ngroup_name=group_name,\nstream=stream,\nresolve_link_to_s=resolve_link_to_s,\nfrom_revision=from_revision,\ncommit_position=commit_position,\nprepare_position=prepare_position,\nextra_statistics=extra_statistics,\nmessage_timeout_ms=message_timeout_ms,\ncheckpoint_after_ms=checkpoint_after_ms,\nmax_retry_count=max_retry_count,\nmin_checkpoint_count=min_checkpoint_count,\nmax_checkpoint_count=max_checkpoint_count,\nmax_subscriber_count=max_subscriber_count,\nlive_buffer_size=live_buffer_size,\nhistory_buffer_size=history_buffer_size,\nread_batch_size=read_batch_size,\nnamed_consumer_strategy=strategy,\n**kwargs,\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/projections/","title":"Projections","text":"<p>Projections Mixin.</p>"},{"location":"reference/eventstore_grpc/client/projections/#eventstore_grpc.client.projections.Projections","title":"<code>Projections</code>","text":"<p>         Bases: <code>ClientBase</code></p> <p>Handles Projections Operations.</p> Source code in <code>src/eventstore_grpc/client/projections.py</code> <pre><code>class Projections(ClientBase):\n\"\"\"Handles Projections Operations.\"\"\"\ndef create_continuous_projection(\nself, name: str, query: str, track_emitted_streams: bool = False, **kwargs\n) -&gt; projections_pb2.CreateResp:\n\"\"\"Creates a continuous projection.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.create_continuous_projection(\nstub,\nname=name,\nquery=query,\ntrack_emitted_streams=track_emitted_streams,\n**kwargs\n)\nreturn result\ndef create_one_time_projection(\nself, query: str, track_emitted_streams: bool = False, **kwargs\n) -&gt; projections_pb2.CreateResp:\n\"\"\"Creates a one time projection.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.create_one_time_projection(\nstub, query=query, track_emitted_streams=track_emitted_streams, **kwargs\n)\nreturn result\ndef create_transient_projection(\nself, name: str, query: str, **kwargs\n) -&gt; projections_pb2.CreateResp:\n\"\"\"Creates a transient projection.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.create_transient_projection(\nstub, name=name, query=query, **kwargs\n)\nreturn result\ndef delete_projection(\nself,\nname: str,\ndelete_emitted_streams: bool = True,\ndelete_state_stream: bool = True,\ndelete_checkpoint_stream: bool = True,\n**kwargs\n) -&gt; projections_pb2.DeleteResp:\n\"\"\"Deletes a projection.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.delete_projection(\nstub,\nname=name,\ndelete_emitted_streams=delete_emitted_streams,\ndelete_state_stream=delete_state_stream,\ndelete_checkpoint_stream=delete_checkpoint_stream,\n**kwargs\n)\nreturn result\ndef disable_projection(\nself, name: str, write_checkpoint: bool = True, **kwargs\n) -&gt; projections_pb2.DisableResp:\n\"\"\"Disables a projection.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.disable_projection(\nstub, name=name, write_checkpoint=write_checkpoint, **kwargs\n)\nreturn result\ndef enable_projection(self, name: str, **kwargs) -&gt; projections_pb2.EnableResp:\n\"\"\"Enables a projection.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.enable_projection(stub, name=name, **kwargs)\nreturn result\ndef list_continuous_projections(\nself, **kwargs\n) -&gt; Iterable[projections_pb2.StatisticsResp]:\n\"\"\"Lists continuous projections.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.list_continuous_projections(stub, **kwargs)\nreturn result\ndef list_one_time_projections(\nself, **kwargs\n) -&gt; Iterable[projections_pb2.StatisticsResp]:\n\"\"\"Lists one time projections.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.list_one_time_projections(stub, **kwargs)\nreturn result\ndef list_transient_projections(\nself, **kwargs\n) -&gt; Iterable[projections_pb2.StatisticsResp]:\n\"\"\"List transient projections.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.list_transient_projections(stub, **kwargs)\nreturn result\ndef reset_projection(\nself, name: str, write_checkpoint: bool = True, **kwargs\n) -&gt; projections_pb2.ResetResp:\n\"\"\"Resets a projection.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.reset_projection(\nstub, name=name, write_checkpoint=write_checkpoint, **kwargs\n)\nreturn result\ndef restart_projections_subsystem(self, **kwargs) -&gt; shared_pb2.Empty:\n\"\"\"Restarts projections subsystem.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.restart_projections_subsystem(stub, **kwargs)\nreturn result\ndef get_projection_result(\nself, name: str, from_partition: Optional[str] = None, **kwargs\n) -&gt; projections_pb2.ResultResp:\n\"\"\"Gets a projection result.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.get_projection_result(\nstub, name=name, from_partition=from_partition, **kwargs\n)\nreturn result\ndef get_projection_state(self, name: str, **kwargs) -&gt; projections_pb2.StateResp:\n\"\"\"Gets a projection's state.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.get_projection_state(stub, name=name, **kwargs)\nreturn result\ndef get_projection_statistics(\nself, name: str, **kwargs\n) -&gt; Iterable[projections_pb2.StatisticsResp]:\n\"\"\"Gets projection statistics.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.get_projection_statistics(stub, name=name, **kwargs)\nreturn result\ndef update_projection(\nself,\nname: str,\nquery: str,\ntrack_emitted_streams: Optional[bool] = None,\n**kwargs\n) -&gt; projections_pb2.UpdateResp:\n\"\"\"Updates a projection.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.update_projection(\nstub,\nname=name,\nquery=query,\ntrack_emitted_streams=track_emitted_streams,\n**kwargs\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/projections/#eventstore_grpc.client.projections.Projections.create_continuous_projection","title":"<code>create_continuous_projection(name, query, track_emitted_streams=False, **kwargs)</code>","text":"<p>Creates a continuous projection.</p> Source code in <code>src/eventstore_grpc/client/projections.py</code> <pre><code>def create_continuous_projection(\nself, name: str, query: str, track_emitted_streams: bool = False, **kwargs\n) -&gt; projections_pb2.CreateResp:\n\"\"\"Creates a continuous projection.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.create_continuous_projection(\nstub,\nname=name,\nquery=query,\ntrack_emitted_streams=track_emitted_streams,\n**kwargs\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/projections/#eventstore_grpc.client.projections.Projections.create_one_time_projection","title":"<code>create_one_time_projection(query, track_emitted_streams=False, **kwargs)</code>","text":"<p>Creates a one time projection.</p> Source code in <code>src/eventstore_grpc/client/projections.py</code> <pre><code>def create_one_time_projection(\nself, query: str, track_emitted_streams: bool = False, **kwargs\n) -&gt; projections_pb2.CreateResp:\n\"\"\"Creates a one time projection.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.create_one_time_projection(\nstub, query=query, track_emitted_streams=track_emitted_streams, **kwargs\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/projections/#eventstore_grpc.client.projections.Projections.create_transient_projection","title":"<code>create_transient_projection(name, query, **kwargs)</code>","text":"<p>Creates a transient projection.</p> Source code in <code>src/eventstore_grpc/client/projections.py</code> <pre><code>def create_transient_projection(\nself, name: str, query: str, **kwargs\n) -&gt; projections_pb2.CreateResp:\n\"\"\"Creates a transient projection.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.create_transient_projection(\nstub, name=name, query=query, **kwargs\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/projections/#eventstore_grpc.client.projections.Projections.delete_projection","title":"<code>delete_projection(name, delete_emitted_streams=True, delete_state_stream=True, delete_checkpoint_stream=True, **kwargs)</code>","text":"<p>Deletes a projection.</p> Source code in <code>src/eventstore_grpc/client/projections.py</code> <pre><code>def delete_projection(\nself,\nname: str,\ndelete_emitted_streams: bool = True,\ndelete_state_stream: bool = True,\ndelete_checkpoint_stream: bool = True,\n**kwargs\n) -&gt; projections_pb2.DeleteResp:\n\"\"\"Deletes a projection.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.delete_projection(\nstub,\nname=name,\ndelete_emitted_streams=delete_emitted_streams,\ndelete_state_stream=delete_state_stream,\ndelete_checkpoint_stream=delete_checkpoint_stream,\n**kwargs\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/projections/#eventstore_grpc.client.projections.Projections.disable_projection","title":"<code>disable_projection(name, write_checkpoint=True, **kwargs)</code>","text":"<p>Disables a projection.</p> Source code in <code>src/eventstore_grpc/client/projections.py</code> <pre><code>def disable_projection(\nself, name: str, write_checkpoint: bool = True, **kwargs\n) -&gt; projections_pb2.DisableResp:\n\"\"\"Disables a projection.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.disable_projection(\nstub, name=name, write_checkpoint=write_checkpoint, **kwargs\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/projections/#eventstore_grpc.client.projections.Projections.enable_projection","title":"<code>enable_projection(name, **kwargs)</code>","text":"<p>Enables a projection.</p> Source code in <code>src/eventstore_grpc/client/projections.py</code> <pre><code>def enable_projection(self, name: str, **kwargs) -&gt; projections_pb2.EnableResp:\n\"\"\"Enables a projection.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.enable_projection(stub, name=name, **kwargs)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/projections/#eventstore_grpc.client.projections.Projections.get_projection_result","title":"<code>get_projection_result(name, from_partition=None, **kwargs)</code>","text":"<p>Gets a projection result.</p> Source code in <code>src/eventstore_grpc/client/projections.py</code> <pre><code>def get_projection_result(\nself, name: str, from_partition: Optional[str] = None, **kwargs\n) -&gt; projections_pb2.ResultResp:\n\"\"\"Gets a projection result.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.get_projection_result(\nstub, name=name, from_partition=from_partition, **kwargs\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/projections/#eventstore_grpc.client.projections.Projections.get_projection_state","title":"<code>get_projection_state(name, **kwargs)</code>","text":"<p>Gets a projection's state.</p> Source code in <code>src/eventstore_grpc/client/projections.py</code> <pre><code>def get_projection_state(self, name: str, **kwargs) -&gt; projections_pb2.StateResp:\n\"\"\"Gets a projection's state.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.get_projection_state(stub, name=name, **kwargs)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/projections/#eventstore_grpc.client.projections.Projections.get_projection_statistics","title":"<code>get_projection_statistics(name, **kwargs)</code>","text":"<p>Gets projection statistics.</p> Source code in <code>src/eventstore_grpc/client/projections.py</code> <pre><code>def get_projection_statistics(\nself, name: str, **kwargs\n) -&gt; Iterable[projections_pb2.StatisticsResp]:\n\"\"\"Gets projection statistics.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.get_projection_statistics(stub, name=name, **kwargs)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/projections/#eventstore_grpc.client.projections.Projections.list_continuous_projections","title":"<code>list_continuous_projections(**kwargs)</code>","text":"<p>Lists continuous projections.</p> Source code in <code>src/eventstore_grpc/client/projections.py</code> <pre><code>def list_continuous_projections(\nself, **kwargs\n) -&gt; Iterable[projections_pb2.StatisticsResp]:\n\"\"\"Lists continuous projections.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.list_continuous_projections(stub, **kwargs)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/projections/#eventstore_grpc.client.projections.Projections.list_one_time_projections","title":"<code>list_one_time_projections(**kwargs)</code>","text":"<p>Lists one time projections.</p> Source code in <code>src/eventstore_grpc/client/projections.py</code> <pre><code>def list_one_time_projections(\nself, **kwargs\n) -&gt; Iterable[projections_pb2.StatisticsResp]:\n\"\"\"Lists one time projections.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.list_one_time_projections(stub, **kwargs)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/projections/#eventstore_grpc.client.projections.Projections.list_transient_projections","title":"<code>list_transient_projections(**kwargs)</code>","text":"<p>List transient projections.</p> Source code in <code>src/eventstore_grpc/client/projections.py</code> <pre><code>def list_transient_projections(\nself, **kwargs\n) -&gt; Iterable[projections_pb2.StatisticsResp]:\n\"\"\"List transient projections.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.list_transient_projections(stub, **kwargs)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/projections/#eventstore_grpc.client.projections.Projections.reset_projection","title":"<code>reset_projection(name, write_checkpoint=True, **kwargs)</code>","text":"<p>Resets a projection.</p> Source code in <code>src/eventstore_grpc/client/projections.py</code> <pre><code>def reset_projection(\nself, name: str, write_checkpoint: bool = True, **kwargs\n) -&gt; projections_pb2.ResetResp:\n\"\"\"Resets a projection.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.reset_projection(\nstub, name=name, write_checkpoint=write_checkpoint, **kwargs\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/projections/#eventstore_grpc.client.projections.Projections.restart_projections_subsystem","title":"<code>restart_projections_subsystem(**kwargs)</code>","text":"<p>Restarts projections subsystem.</p> Source code in <code>src/eventstore_grpc/client/projections.py</code> <pre><code>def restart_projections_subsystem(self, **kwargs) -&gt; shared_pb2.Empty:\n\"\"\"Restarts projections subsystem.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.restart_projections_subsystem(stub, **kwargs)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/projections/#eventstore_grpc.client.projections.Projections.update_projection","title":"<code>update_projection(name, query, track_emitted_streams=None, **kwargs)</code>","text":"<p>Updates a projection.</p> Source code in <code>src/eventstore_grpc/client/projections.py</code> <pre><code>def update_projection(\nself,\nname: str,\nquery: str,\ntrack_emitted_streams: Optional[bool] = None,\n**kwargs\n) -&gt; projections_pb2.UpdateResp:\n\"\"\"Updates a projection.\"\"\"\nstub = projections_pb2_grpc.ProjectionsStub(self.channel)\nresult = projections.update_projection(\nstub,\nname=name,\nquery=query,\ntrack_emitted_streams=track_emitted_streams,\n**kwargs\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/streams/","title":"Streams","text":"<p>Streams Mixins.</p>"},{"location":"reference/eventstore_grpc/client/streams/#eventstore_grpc.client.streams.Streams","title":"<code>Streams</code>","text":"<p>         Bases: <code>ClientBase</code></p> <p>Handles streams operations.</p> Source code in <code>src/eventstore_grpc/client/streams.py</code> <pre><code>class Streams(ClientBase):\n\"\"\"Handles streams operations.\"\"\"\ndef append_to_stream(\nself,\nstream: str,\nevents: Union[event_data.EventData, List[event_data.EventData]],\nexpected_version: Union[str, int] = constants.ANY,\nuser_credentials: append.UserCredentials = None,\n**kwargs\n) -&gt; streams_pb2.AppendResp:\n\"\"\"Appends new events to a stream.\"\"\"\nstub = streams_pb2_grpc.StreamsStub(self.channel)\nresult = append.append_to_stream(\nstub,\nstream=stream,\nexpected_version=expected_version,\nevents=events,\nuser_credentials=user_credentials,\n**kwargs\n)\nreturn result\ndef read_from_stream(\nself,\nstream: str,\ncount: int = None,\nfrom_revision: Union[int, str] = constants.START,\noptions: dict = None,\n**kwargs\n):\n\"\"\"Reads events from a stream.\"\"\"\noptions = options or {}\nif options.get(\"from_revision\") is None:\noptions[\"from_revision\"] = from_revision\nstub = streams_pb2_grpc.StreamsStub(self.channel)\nresult = read.read_from_stream(\nstub, stream=stream, count=count, options=options, **kwargs\n)\nreturn result\ndef read_from_all(\nself,\nfrom_position: Union[Dict[str, int], str] = constants.START,\ncount: int = None,\ndirection: str = None,\n**kwargs\n):\nstub = streams_pb2_grpc.StreamsStub(self.channel)\nresult = read.read_from_all(\nstub,\nfrom_position=from_position,\ncount=count,\ndirection=direction,\n**kwargs\n)\nreturn result\ndef delete_stream(\nself, stream: str, expected_version: Union[int, str] = constants.ANY, **kwargs\n):\n\"\"\"Deletes a stream.\"\"\"\nstub = streams_pb2_grpc.StreamsStub(self.channel)\nresult = delete.delete_stream(\nstub, stream=stream, expected_version=expected_version, **kwargs\n)\nreturn result\ndef tombstone_stream(\nself, stream: str, expected_version: Union[int, str], **kwargs\n):\n\"\"\"Tombstones a stream.\"\"\"\nstub = streams_pb2_grpc.StreamsStub(self.channel)\nresult = tombstone.tombstone_stream(\nstub, stream=stream, expected_version=expected_version, **kwargs\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/streams/#eventstore_grpc.client.streams.Streams.append_to_stream","title":"<code>append_to_stream(stream, events, expected_version=constants.ANY, user_credentials=None, **kwargs)</code>","text":"<p>Appends new events to a stream.</p> Source code in <code>src/eventstore_grpc/client/streams.py</code> <pre><code>def append_to_stream(\nself,\nstream: str,\nevents: Union[event_data.EventData, List[event_data.EventData]],\nexpected_version: Union[str, int] = constants.ANY,\nuser_credentials: append.UserCredentials = None,\n**kwargs\n) -&gt; streams_pb2.AppendResp:\n\"\"\"Appends new events to a stream.\"\"\"\nstub = streams_pb2_grpc.StreamsStub(self.channel)\nresult = append.append_to_stream(\nstub,\nstream=stream,\nexpected_version=expected_version,\nevents=events,\nuser_credentials=user_credentials,\n**kwargs\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/streams/#eventstore_grpc.client.streams.Streams.delete_stream","title":"<code>delete_stream(stream, expected_version=constants.ANY, **kwargs)</code>","text":"<p>Deletes a stream.</p> Source code in <code>src/eventstore_grpc/client/streams.py</code> <pre><code>def delete_stream(\nself, stream: str, expected_version: Union[int, str] = constants.ANY, **kwargs\n):\n\"\"\"Deletes a stream.\"\"\"\nstub = streams_pb2_grpc.StreamsStub(self.channel)\nresult = delete.delete_stream(\nstub, stream=stream, expected_version=expected_version, **kwargs\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/streams/#eventstore_grpc.client.streams.Streams.read_from_stream","title":"<code>read_from_stream(stream, count=None, from_revision=constants.START, options=None, **kwargs)</code>","text":"<p>Reads events from a stream.</p> Source code in <code>src/eventstore_grpc/client/streams.py</code> <pre><code>def read_from_stream(\nself,\nstream: str,\ncount: int = None,\nfrom_revision: Union[int, str] = constants.START,\noptions: dict = None,\n**kwargs\n):\n\"\"\"Reads events from a stream.\"\"\"\noptions = options or {}\nif options.get(\"from_revision\") is None:\noptions[\"from_revision\"] = from_revision\nstub = streams_pb2_grpc.StreamsStub(self.channel)\nresult = read.read_from_stream(\nstub, stream=stream, count=count, options=options, **kwargs\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/streams/#eventstore_grpc.client.streams.Streams.tombstone_stream","title":"<code>tombstone_stream(stream, expected_version, **kwargs)</code>","text":"<p>Tombstones a stream.</p> Source code in <code>src/eventstore_grpc/client/streams.py</code> <pre><code>def tombstone_stream(\nself, stream: str, expected_version: Union[int, str], **kwargs\n):\n\"\"\"Tombstones a stream.\"\"\"\nstub = streams_pb2_grpc.StreamsStub(self.channel)\nresult = tombstone.tombstone_stream(\nstub, stream=stream, expected_version=expected_version, **kwargs\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/subscriptions/","title":"Subscriptions","text":"<p>Subscriptions Mixin.</p>"},{"location":"reference/eventstore_grpc/client/subscriptions/#eventstore_grpc.client.subscriptions.Subscriptions","title":"<code>Subscriptions</code>","text":"<p>         Bases: <code>ClientBase</code></p> <p>Handles Subscriptions operations.</p> Source code in <code>src/eventstore_grpc/client/subscriptions.py</code> <pre><code>class Subscriptions(ClientBase):\n\"\"\"Handles Subscriptions operations.\"\"\"\ndef _initialize_subscriptions_manager(self):\nif getattr(self, \"_subscriptions_manager\", None) is None:\nself._subscriptions_manager = subscriptions.SubscriptionsManager(\nself.channel\n)\nsignal.signal(signal.SIGINT, self.kill)\nsignal.signal(signal.SIGTERM, self.kill)\ndef kill(self, signum, frame):\nlog.info(\"\\033[38;5;120mGracefully shutting down...\\033[0m\")\nself.unsubscribe_all()\ndef subscribe_to_stream(\nself,\nstream: str,\nfrom_revision: Union[str, int] = constants.START,\nresolve_link_to_s: bool = False,\nhandler: Optional[Callable] = None,\n**kwargs,\n):\nself._initialize_subscriptions_manager()\nsubscription_id = self._subscriptions_manager.subscribe_to_stream(\nstream=stream,\nfrom_revision=from_revision,\nresolve_link_to_s=resolve_link_to_s,\nhandler=handler,\n**kwargs,\n)\nreturn subscription_id\ndef subscribe_to_all(\nself,\nfrom_position: Union[str, int] = constants.START,\nresolve_link_to_s: bool = False,\nfilters: Optional[Dict] = None,\nhandler: Optional[Callable] = None,\n**kwargs,\n):\nself._initialize_subscriptions_manager()\nsubscription_id = self._subscriptions_manager.subscribe_to_all(\nfrom_position=from_position,\nresolve_link_to_s=resolve_link_to_s,\nfilters=filters,\nhandler=handler,\n**kwargs,\n)\nreturn subscription_id\ndef subscribe_persistent(\nself,\nstream: str,\ngroup_name: str,\nbuffer_size: int = 10,\nhandler: Optional[Callable] = None,\n**kwargs,\n):\nself._initialize_subscriptions_manager()\nsubscription_id = self._subscriptions_manager.subscribe_persistent(\nstream=stream,\ngroup_name=group_name,\nbuffer_size=buffer_size,\nhandler=handler,\n**kwargs,\n)\nreturn subscription_id\ndef unsubscribe(self, subscription_id: str):\nself._initialize_subscriptions_manager()\nreturn self._subscriptions_manager.unsubscribe(subscription_id)\ndef unsubscribe_all(self):\nself._initialize_subscriptions_manager()\nfor k in self._subscriptions_manager.subscription_ids:\nself.unsubscribe(k)\n</code></pre>"},{"location":"reference/eventstore_grpc/client/users/","title":"Users","text":"<p>Users Mixins.</p>"},{"location":"reference/eventstore_grpc/client/users/#eventstore_grpc.client.users.Users","title":"<code>Users</code>","text":"<p>         Bases: <code>ClientBase</code></p> <p>Handles Users Operations.</p> Source code in <code>src/eventstore_grpc/client/users.py</code> <pre><code>class Users(ClientBase):\n\"\"\"Handles Users Operations.\"\"\"\ndef create_user(\nself,\nlogin_name: str,\npassword: str,\nfull_name: str,\ngroups: Optional[List[str]] = None,\n**kwargs,\n) -&gt; users_pb2.CreateResp:\n\"\"\"Creates a new user.\"\"\"\nstub = users_pb2_grpc.UsersStub(self.channel)\nif groups is None:\ngroups = []\nresult = users.create(\nstub,\nlogin_name=login_name,\npassword=password,\nfull_name=full_name,\ngroups=groups,\n**kwargs,\n)\nreturn result\ndef update_user(\nself,\nlogin_name: Optional[str] = None,\npassword: Optional[str] = None,\nfull_name: Optional[str] = None,\ngroups: Optional[List[str]] = None,\n**kwargs,\n) -&gt; users_pb2.UpdateResp:\n\"\"\"Updates an existing user information.\"\"\"\nstub = users_pb2_grpc.UsersStub(self.channel)\nupdates: dict[str, str | list[str]] = {}\nif login_name is not None:\nupdates[\"login_name\"] = login_name\nif password is not None:\nupdates[\"password\"] = password\nif full_name is not None:\nupdates[\"full_name\"] = full_name\nif groups is not None:\nupdates[\"groups\"] = groups\nif not updates:\nraise ValueError(\"No updates.\")\nresult = users.update(stub, **updates, **kwargs)  # type: ignore\nreturn result\ndef delete_user(self, login_name: str, **kwargs) -&gt; users_pb2.DeleteResp:\n\"\"\"Deletes a user.\"\"\"\nstub = users_pb2_grpc.UsersStub(self.channel)\nresult = users.delete(stub, login_name=login_name, **kwargs)\nreturn result\ndef enable_user(self, login_name: str, **kwargs) -&gt; users_pb2.EnableResp:\n\"\"\"Enables a user.\"\"\"\nstub = users_pb2_grpc.UsersStub(self.channel)\nresult = users.enable(stub, login_name=login_name, **kwargs)\nreturn result\ndef disable_user(self, login_name: str, **kwargs) -&gt; users_pb2.DisableResp:\n\"\"\"Disables a user.\"\"\"\nstub = users_pb2_grpc.UsersStub(self.channel)\nresult = users.disable(stub, login_name=login_name, **kwargs)\nreturn result\ndef get_user_details(self, login_name: str, **kwargs) -&gt; users_pb2.DetailsResp:\n\"\"\"Gets details about a user.\"\"\"\nstub = users_pb2_grpc.UsersStub(self.channel)\nresult = users.details(stub, login_name=login_name, **kwargs)\nreturn next(result)  # type: ignore\ndef change_user_password(\nself, login_name: str, current_password: str, new_password: str, **kwargs\n) -&gt; users_pb2.ChangePasswordResp:\n\"\"\"Changes a user's password.\"\"\"\nstub = users_pb2_grpc.UsersStub(self.channel)\nresult = users.change_password(\nstub,\nlogin_name=login_name,\ncurrent_password=current_password,\nnew_password=new_password,\n**kwargs,\n)\nreturn result\ndef reset_user_password(\nself, login_name: str, new_password: str, **kwargs\n) -&gt; users_pb2.ResetPasswordResp:\n\"\"\"Resets a user's password.\"\"\"\nstub = users_pb2_grpc.UsersStub(self.channel)\nresult = users.reset_password(\nstub, login_name=login_name, new_password=new_password, **kwargs\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/users/#eventstore_grpc.client.users.Users.change_user_password","title":"<code>change_user_password(login_name, current_password, new_password, **kwargs)</code>","text":"<p>Changes a user's password.</p> Source code in <code>src/eventstore_grpc/client/users.py</code> <pre><code>def change_user_password(\nself, login_name: str, current_password: str, new_password: str, **kwargs\n) -&gt; users_pb2.ChangePasswordResp:\n\"\"\"Changes a user's password.\"\"\"\nstub = users_pb2_grpc.UsersStub(self.channel)\nresult = users.change_password(\nstub,\nlogin_name=login_name,\ncurrent_password=current_password,\nnew_password=new_password,\n**kwargs,\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/users/#eventstore_grpc.client.users.Users.create_user","title":"<code>create_user(login_name, password, full_name, groups=None, **kwargs)</code>","text":"<p>Creates a new user.</p> Source code in <code>src/eventstore_grpc/client/users.py</code> <pre><code>def create_user(\nself,\nlogin_name: str,\npassword: str,\nfull_name: str,\ngroups: Optional[List[str]] = None,\n**kwargs,\n) -&gt; users_pb2.CreateResp:\n\"\"\"Creates a new user.\"\"\"\nstub = users_pb2_grpc.UsersStub(self.channel)\nif groups is None:\ngroups = []\nresult = users.create(\nstub,\nlogin_name=login_name,\npassword=password,\nfull_name=full_name,\ngroups=groups,\n**kwargs,\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/users/#eventstore_grpc.client.users.Users.delete_user","title":"<code>delete_user(login_name, **kwargs)</code>","text":"<p>Deletes a user.</p> Source code in <code>src/eventstore_grpc/client/users.py</code> <pre><code>def delete_user(self, login_name: str, **kwargs) -&gt; users_pb2.DeleteResp:\n\"\"\"Deletes a user.\"\"\"\nstub = users_pb2_grpc.UsersStub(self.channel)\nresult = users.delete(stub, login_name=login_name, **kwargs)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/users/#eventstore_grpc.client.users.Users.disable_user","title":"<code>disable_user(login_name, **kwargs)</code>","text":"<p>Disables a user.</p> Source code in <code>src/eventstore_grpc/client/users.py</code> <pre><code>def disable_user(self, login_name: str, **kwargs) -&gt; users_pb2.DisableResp:\n\"\"\"Disables a user.\"\"\"\nstub = users_pb2_grpc.UsersStub(self.channel)\nresult = users.disable(stub, login_name=login_name, **kwargs)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/users/#eventstore_grpc.client.users.Users.enable_user","title":"<code>enable_user(login_name, **kwargs)</code>","text":"<p>Enables a user.</p> Source code in <code>src/eventstore_grpc/client/users.py</code> <pre><code>def enable_user(self, login_name: str, **kwargs) -&gt; users_pb2.EnableResp:\n\"\"\"Enables a user.\"\"\"\nstub = users_pb2_grpc.UsersStub(self.channel)\nresult = users.enable(stub, login_name=login_name, **kwargs)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/users/#eventstore_grpc.client.users.Users.get_user_details","title":"<code>get_user_details(login_name, **kwargs)</code>","text":"<p>Gets details about a user.</p> Source code in <code>src/eventstore_grpc/client/users.py</code> <pre><code>def get_user_details(self, login_name: str, **kwargs) -&gt; users_pb2.DetailsResp:\n\"\"\"Gets details about a user.\"\"\"\nstub = users_pb2_grpc.UsersStub(self.channel)\nresult = users.details(stub, login_name=login_name, **kwargs)\nreturn next(result)  # type: ignore\n</code></pre>"},{"location":"reference/eventstore_grpc/client/users/#eventstore_grpc.client.users.Users.reset_user_password","title":"<code>reset_user_password(login_name, new_password, **kwargs)</code>","text":"<p>Resets a user's password.</p> Source code in <code>src/eventstore_grpc/client/users.py</code> <pre><code>def reset_user_password(\nself, login_name: str, new_password: str, **kwargs\n) -&gt; users_pb2.ResetPasswordResp:\n\"\"\"Resets a user's password.\"\"\"\nstub = users_pb2_grpc.UsersStub(self.channel)\nresult = users.reset_password(\nstub, login_name=login_name, new_password=new_password, **kwargs\n)\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/client/users/#eventstore_grpc.client.users.Users.update_user","title":"<code>update_user(login_name=None, password=None, full_name=None, groups=None, **kwargs)</code>","text":"<p>Updates an existing user information.</p> Source code in <code>src/eventstore_grpc/client/users.py</code> <pre><code>def update_user(\nself,\nlogin_name: Optional[str] = None,\npassword: Optional[str] = None,\nfull_name: Optional[str] = None,\ngroups: Optional[List[str]] = None,\n**kwargs,\n) -&gt; users_pb2.UpdateResp:\n\"\"\"Updates an existing user information.\"\"\"\nstub = users_pb2_grpc.UsersStub(self.channel)\nupdates: dict[str, str | list[str]] = {}\nif login_name is not None:\nupdates[\"login_name\"] = login_name\nif password is not None:\nupdates[\"password\"] = password\nif full_name is not None:\nupdates[\"full_name\"] = full_name\nif groups is not None:\nupdates[\"groups\"] = groups\nif not updates:\nraise ValueError(\"No updates.\")\nresult = users.update(stub, **updates, **kwargs)  # type: ignore\nreturn result\n</code></pre>"},{"location":"reference/eventstore_grpc/core/__init__/","title":"init","text":""},{"location":"reference/eventstore_grpc/core/auth/","title":"Auth","text":"<p>https://developers.eventstore.com/clients/dotnet/5.0/security.html#authentication-and-authorization</p>"},{"location":"reference/eventstore_grpc/core/auth/#eventstore_grpc.core.auth.Auth","title":"<code>Auth</code>","text":"<p>Manages authentication/authorization for the client.</p> Source code in <code>src/eventstore_grpc/core/auth.py</code> <pre><code>class Auth:\n\"\"\"Manages authentication/authorization for the client.\"\"\"\ndef __init__(\nself, username: str = None, password: str = None, root_certificate: str = None\n) -&gt; None:\n\"\"\"Initializes the AuthManager.\n        Args:\n            username: the username.\n            password: the password.\n            root_certificate: the path to the root certificate.\n        \"\"\"\nself._username = username\nself._password = password\nself._root_certificate = root_certificate\nself._channel_credentials = None\nself._call_credentials = None\nif root_certificate is not None:\nself._channel_credentials = self._get_channel_credentials()\nif self.token:\nself._call_credentials = self._get_call_credentials()\n@property\ndef username(self) -&gt; str | None:\nreturn self._username\n@username.setter\ndef username(self, value: str) -&gt; None:\nself._username = value\nif self._password:\nself._call_credentials = self._get_call_credentials()\n@property\ndef password(self) -&gt; str | None:\nreturn self._password\n@password.setter\ndef password(self, value: str) -&gt; None:\nself._password = value\nif self._username:\nself._call_credentials = self._get_call_credentials()\n@property\ndef token(self) -&gt; str | None:\n\"\"\"Base64 encoded username:passsword.\"\"\"\nif not self._username and not self._password:\nreturn None\nreturn base64.b64encode(\nf\"{self._username}:{self._password}\".encode(\"ascii\")\n).decode(\"ascii\")\n@property\ndef credentials(self) -&gt; grpc.ChannelCredentials:\nif not self._channel_credentials and not self._call_credentials:\nreturn None\nelif self._channel_credentials and self._call_credentials:\nreturn grpc.composite_channel_credentials(\nself._channel_credentials, self._call_credentials\n)\nelif self._channel_credentials and not self._call_credentials:\nreturn self._channel_credentials\nreturn None\ndef _get_channel_credentials(self) -&gt; grpc.ChannelCredentials:\nif self._root_certificate is None:\nraise ValueError(\nf\"Can't _get_channel_credentials if _root_certificate is None.\"\n)\nwith open(self._root_certificate, \"rb\") as f:\nrc = f.read()\nreturn grpc.ssl_channel_credentials(root_certificates=rc)\ndef _get_call_credentials(self) -&gt; grpc.CallCredentials:\nif self.token is None:\nraise ValueError(\"Can't _get_call_credentials if token is None.\")\nreturn grpc.metadata_call_credentials(\nEventStoreDBMetadataPlugin(token=self.token)\n)\n</code></pre>"},{"location":"reference/eventstore_grpc/core/auth/#eventstore_grpc.core.auth.Auth.token","title":"<code>token: str | None</code>  <code>property</code>","text":"<p>Base64 encoded username:passsword.</p>"},{"location":"reference/eventstore_grpc/core/auth/#eventstore_grpc.core.auth.Auth.__init__","title":"<code>__init__(username=None, password=None, root_certificate=None)</code>","text":"<p>Initializes the AuthManager.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>the username.</p> <code>None</code> <code>password</code> <code>str</code> <p>the password.</p> <code>None</code> <code>root_certificate</code> <code>str</code> <p>the path to the root certificate.</p> <code>None</code> Source code in <code>src/eventstore_grpc/core/auth.py</code> <pre><code>def __init__(\nself, username: str = None, password: str = None, root_certificate: str = None\n) -&gt; None:\n\"\"\"Initializes the AuthManager.\n    Args:\n        username: the username.\n        password: the password.\n        root_certificate: the path to the root certificate.\n    \"\"\"\nself._username = username\nself._password = password\nself._root_certificate = root_certificate\nself._channel_credentials = None\nself._call_credentials = None\nif root_certificate is not None:\nself._channel_credentials = self._get_channel_credentials()\nif self.token:\nself._call_credentials = self._get_call_credentials()\n</code></pre>"},{"location":"reference/eventstore_grpc/core/client_base/","title":"Client base","text":"<p>EventStoreDB client.</p>"},{"location":"reference/eventstore_grpc/core/client_base/#eventstore_grpc.core.client_base.ClientBase","title":"<code>ClientBase</code>","text":"Source code in <code>src/eventstore_grpc/core/client_base.py</code> <pre><code>class ClientBase:\ndef __init__(self, transport: \"Transport\") -&gt; None:\n\"\"\"Initializes a ClientBase.\n        Args:\n            transport: an instance of a Transport Class.\n        \"\"\"\nself._transport = transport\n@property\ndef channel(self):\n\"\"\"The gRPC channel from the underlying transport class.\"\"\"\nreturn self._transport.channel\n</code></pre>"},{"location":"reference/eventstore_grpc/core/client_base/#eventstore_grpc.core.client_base.ClientBase.channel","title":"<code>channel</code>  <code>property</code>","text":"<p>The gRPC channel from the underlying transport class.</p>"},{"location":"reference/eventstore_grpc/core/client_base/#eventstore_grpc.core.client_base.ClientBase.__init__","title":"<code>__init__(transport)</code>","text":"<p>Initializes a ClientBase.</p> <p>Parameters:</p> Name Type Description Default <code>transport</code> <code>Transport</code> <p>an instance of a Transport Class.</p> required Source code in <code>src/eventstore_grpc/core/client_base.py</code> <pre><code>def __init__(self, transport: \"Transport\") -&gt; None:\n\"\"\"Initializes a ClientBase.\n    Args:\n        transport: an instance of a Transport Class.\n    \"\"\"\nself._transport = transport\n</code></pre>"},{"location":"reference/eventstore_grpc/core/settings/","title":"Settings","text":""},{"location":"reference/eventstore_grpc/core/settings/#eventstore_grpc.core.settings.KeepAlive","title":"<code>KeepAlive</code>  <code>dataclass</code>","text":"<p>KeepAlive settings.</p> Source code in <code>src/eventstore_grpc/core/settings.py</code> <pre><code>@dataclasses.dataclass\nclass KeepAlive:\n\"\"\"KeepAlive settings.\"\"\"\ninterval: int = 10_000  # ms\ntimeout: int = 10_000  # ms\n</code></pre>"},{"location":"reference/eventstore_grpc/core/transport/","title":"Transport","text":"<p>Transport Layer</p>"},{"location":"reference/eventstore_grpc/core/transport/#eventstore_grpc.core.transport.Transport","title":"<code>Transport</code>","text":"Source code in <code>src/eventstore_grpc/core/transport.py</code> <pre><code>class Transport:\ndef __init__(\nself,\nhosts: Union[str, list[str]],\ndiscover: Optional[bool] = None,\ntls: Optional[bool] = None,\nkeep_alive: Optional[KeepAlive] = None,  # TODO: maybe remove?\nauth: Optional[Auth] = None,\n) -&gt; None:\n\"\"\"Transport layer.\"\"\"\nif not isinstance(hosts, list):\nhosts = [hosts]\nif len(hosts) &lt; 1:\nraise ValueError(\"You must specify at least one node.\")\nself._hosts = hosts\nself._auth = auth\nself._tls = tls\nself._keep_alive = keep_alive\nself._discover = discover\nself._channel = self._new_channel()\ndef refresh_channel(self) -&gt; \"Transport\":\n\"\"\"Gets a new channel.\"\"\"\nself._channel = self._new_channel()\nreturn self\ndef _new_channel(self) -&gt; grpc.Channel:\nif self.is_insecure:\nreturn grpc.insecure_channel(self.target)\nreturn grpc.secure_channel(self.target, credentials=self.credentials)\ndef _get_target_node(self) -&gt; str:\n\"\"\"Gets the target node, using discovery when needed.\"\"\"\nif self.multinode_cluster:\nreturn discovery.discover_endpoint(\nself._hosts,\ncredentials=self.credentials if self.tls else None,\n)\nelse:\nreturn self._hosts[-1]\n@property\ndef is_insecure(self) -&gt; bool:\nreturn not self._tls and (\nnot self._auth or not any([self._auth.username, self._auth.password])\n)\n@property\ndef credentials(self) -&gt; grpc.ChannelCredentials | None:\nif self._auth is not None:\nreturn self._auth.credentials\nreturn None\n@property\ndef target(self) -&gt; str:\nreturn self._get_target_node()\n@property\ndef channel(self) -&gt; grpc.Channel:\nreturn self._channel\n@property\ndef multinode_cluster(self) -&gt; bool:\nreturn len(self._hosts) &gt; 1\n@property\ndef hosts(self) -&gt; list[str]:\nreturn self._hosts\n@property\ndef tls(self):\nreturn self._tls\n@property\ndef keep_alive(self) -&gt; KeepAlive | None:\nreturn self._keep_alive\n@property\ndef discover(self) -&gt; bool | None:\nreturn self._discover\n</code></pre>"},{"location":"reference/eventstore_grpc/core/transport/#eventstore_grpc.core.transport.Transport.__init__","title":"<code>__init__(hosts, discover=None, tls=None, keep_alive=None, auth=None)</code>","text":"<p>Transport layer.</p> Source code in <code>src/eventstore_grpc/core/transport.py</code> <pre><code>def __init__(\nself,\nhosts: Union[str, list[str]],\ndiscover: Optional[bool] = None,\ntls: Optional[bool] = None,\nkeep_alive: Optional[KeepAlive] = None,  # TODO: maybe remove?\nauth: Optional[Auth] = None,\n) -&gt; None:\n\"\"\"Transport layer.\"\"\"\nif not isinstance(hosts, list):\nhosts = [hosts]\nif len(hosts) &lt; 1:\nraise ValueError(\"You must specify at least one node.\")\nself._hosts = hosts\nself._auth = auth\nself._tls = tls\nself._keep_alive = keep_alive\nself._discover = discover\nself._channel = self._new_channel()\n</code></pre>"},{"location":"reference/eventstore_grpc/core/transport/#eventstore_grpc.core.transport.Transport.refresh_channel","title":"<code>refresh_channel()</code>","text":"<p>Gets a new channel.</p> Source code in <code>src/eventstore_grpc/core/transport.py</code> <pre><code>def refresh_channel(self) -&gt; \"Transport\":\n\"\"\"Gets a new channel.\"\"\"\nself._channel = self._new_channel()\nreturn self\n</code></pre>"},{"location":"reference/eventstore_grpc/gossip/__init__/","title":"init","text":""},{"location":"reference/eventstore_grpc/gossip/read/","title":"Read","text":"<p>Read Gossip.</p>"},{"location":"reference/eventstore_grpc/gossip/read/#eventstore_grpc.gossip.read.read","title":"<code>read(stub, **kwargs)</code>","text":"<p>Reads Gossip.</p> Source code in <code>src/eventstore_grpc/gossip/read.py</code> <pre><code>def read(stub: gossip_pb2_grpc.GossipStub, **kwargs) -&gt; gossip_pb2.ClusterInfo:\n\"\"\"Reads Gossip.\"\"\"\nreturn stub.Read(shared_pb2.Empty())\n</code></pre>"},{"location":"reference/eventstore_grpc/operations/__init__/","title":"init","text":""},{"location":"reference/eventstore_grpc/operations/merge_indexes/","title":"Merge indexes","text":"<p>Merge Indexes.</p>"},{"location":"reference/eventstore_grpc/operations/merge_indexes/#eventstore_grpc.operations.merge_indexes.merge_indexes","title":"<code>merge_indexes(stub, **kwargs)</code>","text":"<p>Merge Indexes.</p> Source code in <code>src/eventstore_grpc/operations/merge_indexes.py</code> <pre><code>def merge_indexes(\nstub: operations_pb2_grpc.OperationsStub, **kwargs\n) -&gt; shared_pb2.Empty:\n\"\"\"Merge Indexes.\"\"\"\nreturn stub.MergeIndexes(shared_pb2.Empty(), **kwargs)\n</code></pre>"},{"location":"reference/eventstore_grpc/operations/resign_node/","title":"Resign node","text":"<p>Resign Node.</p>"},{"location":"reference/eventstore_grpc/operations/resign_node/#eventstore_grpc.operations.resign_node.resign_node","title":"<code>resign_node(stub, **kwargs)</code>","text":"<p>Resign Node.</p> Source code in <code>src/eventstore_grpc/operations/resign_node.py</code> <pre><code>def resign_node(stub: operations_pb2_grpc.OperationsStub, **kwargs) -&gt; shared_pb2.Empty:\n\"\"\"Resign Node.\"\"\"\nreturn stub.ResignNode(shared_pb2.Empty(), **kwargs)\n</code></pre>"},{"location":"reference/eventstore_grpc/operations/restart_persistent_subscritions/","title":"Restart persistent subscritions","text":"<p>Restart persistent subscriptions.</p>"},{"location":"reference/eventstore_grpc/operations/restart_persistent_subscritions/#eventstore_grpc.operations.restart_persistent_subscritions.restart_persistent_subscriptions","title":"<code>restart_persistent_subscriptions(stub, **kwargs)</code>","text":"<p>Restart persistent subscriptions.</p> Source code in <code>src/eventstore_grpc/operations/restart_persistent_subscritions.py</code> <pre><code>def restart_persistent_subscriptions(\nstub: operations_pb2_grpc.OperationsStub, **kwargs\n) -&gt; shared_pb2.Empty:\n\"\"\"Restart persistent subscriptions.\"\"\"\nreturn stub.RestartPersistentSubscriptions(shared_pb2.Empty(), **kwargs)\n</code></pre>"},{"location":"reference/eventstore_grpc/operations/set_node_priority/","title":"Set node priority","text":"<p>Set Node Priority.</p>"},{"location":"reference/eventstore_grpc/operations/set_node_priority/#eventstore_grpc.operations.set_node_priority.set_node_priority","title":"<code>set_node_priority(stub, priority, **kwargs)</code>","text":"<p>Sets node priority.</p> Source code in <code>src/eventstore_grpc/operations/set_node_priority.py</code> <pre><code>def set_node_priority(\nstub: operations_pb2_grpc.OperationsStub, priority: int, **kwargs\n) -&gt; shared_pb2.Empty:\n\"\"\"Sets node priority.\"\"\"\nrequest = operations_pb2.SetNodePriorityReq()\nrequest.priority = priority\nresponse = stub.SetNodePriority(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/operations/shutdown/","title":"Shutdown","text":"<p>Shutdown.</p>"},{"location":"reference/eventstore_grpc/operations/shutdown/#eventstore_grpc.operations.shutdown.shutdown","title":"<code>shutdown(stub, **kwargs)</code>","text":"<p>Shuts down EvenStoreDB.</p> Source code in <code>src/eventstore_grpc/operations/shutdown.py</code> <pre><code>def shutdown(stub: operations_pb2_grpc.OperationsStub, **kwargs) -&gt; shared_pb2.Empty:\n\"\"\"Shuts down EvenStoreDB.\"\"\"\nreturn stub.Shutdown(shared_pb2.Empty(), **kwargs)\n</code></pre>"},{"location":"reference/eventstore_grpc/operations/start_scavenge/","title":"Start scavenge","text":"<p>Start Scavenge.</p>"},{"location":"reference/eventstore_grpc/operations/start_scavenge/#eventstore_grpc.operations.start_scavenge.start_scavenge","title":"<code>start_scavenge(stub, thread_count, start_from_chunk, **kwargs)</code>","text":"<p>Starts scavenge.</p> Source code in <code>src/eventstore_grpc/operations/start_scavenge.py</code> <pre><code>def start_scavenge(\nstub: operations_pb2_grpc.OperationsStub,\nthread_count: int,\nstart_from_chunk: int,\n**kwargs\n) -&gt; operations_pb2.ScavengeResp:\n\"\"\"Starts scavenge.\"\"\"\nrequest = operations_pb2.StartScavengeReq()\noptions = operations_pb2.StartScavengeReq.Options()\noptions.thread_count = thread_count\noptions.start_from_chunk = start_from_chunk\nrequest.options.CopyFrom(options)\nresponse = stub.StartScavenge(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/operations/stop_scavenge/","title":"Stop scavenge","text":"<p>Stop Scavenge.</p>"},{"location":"reference/eventstore_grpc/operations/stop_scavenge/#eventstore_grpc.operations.stop_scavenge.stop_scavenge","title":"<code>stop_scavenge(stub, scavenge_id, **kwargs)</code>","text":"<p>Stops scavenge.</p> Source code in <code>src/eventstore_grpc/operations/stop_scavenge.py</code> <pre><code>def stop_scavenge(\nstub: operations_pb2_grpc.OperationsStub, scavenge_id: str, **kwargs\n) -&gt; operations_pb2.ScavengeResp:\n\"\"\"Stops scavenge.\"\"\"\nrequest = operations_pb2.StopScavengeReq()\noptions = operations_pb2.StopScavengeReq.Options()\noptions.scavenge_id = scavenge_id\nrequest.options.CopyFrom(options)\nresponse = stub.StopScavenge(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/options/__init__/","title":"init","text":""},{"location":"reference/eventstore_grpc/options/base_options/","title":"Base options","text":"<p>Base Request Options.</p>"},{"location":"reference/eventstore_grpc/options/base_options/#eventstore_grpc.options.base_options.as_metadata","title":"<code>as_metadata(credentials=None, requires_leader=None)</code>","text":"<p>Returns a valid grpc \"metadata\" object.</p> Source code in <code>src/eventstore_grpc/options/base_options.py</code> <pre><code>def as_metadata(\ncredentials: Optional[Dict[str, str]] = None, requires_leader: Optional[bool] = None\n) -&gt; Optional[List[Tuple[str, str]]]:\n\"\"\"Returns a valid grpc \"metadata\" object.\"\"\"\nmetadata = []\nif credentials is not None:\nif all(elm in [\"username\", \"password\"] for elm in credentials):\ntoken = f\"{credentials['username']}:{credentials['password']}\"\ntoken = base64.b64encode(token.encode(\"ascii\")).decode(\"ascii\")\nauth = (\"authorization\", f\"Bearer {token}\")\nmetadata.append(auth)\nif requires_leader is not None:\nreq_leader = (\"requires-leader\", str(requires_leader).lower())\nmetadata.append(req_leader)\nreturn metadata if metadata else None\n</code></pre>"},{"location":"reference/eventstore_grpc/options/channel_credential/","title":"Channel credential","text":"<p>Channel Credential Options.</p>"},{"location":"reference/eventstore_grpc/options/client/","title":"Client","text":"<p>Client Options.</p>"},{"location":"reference/eventstore_grpc/options/connection_type/","title":"Connection type","text":"<p>Connection Type Options.</p>"},{"location":"reference/eventstore_grpc/options/discovery/","title":"Discovery","text":"<p>Discovery Options.</p>"},{"location":"reference/eventstore_grpc/options/dns_cluster/","title":"Dns cluster","text":"<p>DNS Cluster Options.</p>"},{"location":"reference/eventstore_grpc/options/gossip_cluster/","title":"Gossip cluster","text":"<p>Gossip Cluster Options.</p>"},{"location":"reference/eventstore_grpc/options/single_node/","title":"Single node","text":"<p>Single Node Options.</p>"},{"location":"reference/eventstore_grpc/persistent/__init__/","title":"init","text":""},{"location":"reference/eventstore_grpc/persistent/create/","title":"Create","text":"<p>Create persistent subscription.</p>"},{"location":"reference/eventstore_grpc/persistent/create/#eventstore_grpc.persistent.create.create_persistent_subscription","title":"<code>create_persistent_subscription(stub, group_name, stream=None, resolve_link_to_s=False, from_revision=START, commit_position=None, prepare_position=None, extra_statistics=False, message_timeout_ms=30000, checkpoint_after_ms=2000, max_retry_count=10, min_checkpoint_count=10, max_checkpoint_count=1000, max_subscriber_count=0, live_buffer_size=500, history_buffer_size=500, read_batch_size=20, strategy=ROUND_ROBIN, filter_options=None, **kwargs)</code>","text":"<p>Creates a persistent subscription.</p> Source code in <code>src/eventstore_grpc/persistent/create.py</code> <pre><code>def create_persistent_subscription(\nstub: persistent_pb2_grpc.PersistentSubscriptionsStub,\ngroup_name: str | None,\nstream: str | None = None,\nresolve_link_to_s: bool = False,\nfrom_revision: Union[int, str] = START,\ncommit_position: Optional[int] = None,\nprepare_position: Optional[int] = None,\nextra_statistics: bool = False,\nmessage_timeout_ms: int = 30000,\ncheckpoint_after_ms: int = 2000,\nmax_retry_count: int = 10,\nmin_checkpoint_count: int = 10,\nmax_checkpoint_count: int = 1000,\nmax_subscriber_count: int = 0,\nlive_buffer_size: int = 500,\nhistory_buffer_size: int = 500,\nread_batch_size: int = 20,\nstrategy: str = ROUND_ROBIN,\nfilter_options: Optional[persistent_pb2.CreateReq.AllOptions.FilterOptions] = None,\n**kwargs,\n) -&gt; persistent_pb2.CreateResp:\n\"\"\"Creates a persistent subscription.\"\"\"\nif history_buffer_size is None:\n# TODO: talk with EventStoreDB about this behavior?\nlog.warning(\nf\"If you don't send `history_buffer_size` EventStoreDB will hang indefinitely: forcing it to its default value -&gt; 500\"\n)\nhistory_buffer_size = 500\nsettings = _build_settings(\nresolve_link_to_s=resolve_link_to_s,\nextra_statistics=extra_statistics,\nmax_retry_count=max_retry_count,\nmin_checkpoint_count=min_checkpoint_count,\nmax_checkpoint_count=max_checkpoint_count,\nmax_subscriber_count=max_subscriber_count,\nlive_buffer_size=live_buffer_size,\nread_batch_size=read_batch_size,\nhistory_buffer_size=history_buffer_size,\nmessage_timeout_ms=message_timeout_ms,\ncheckpoint_after_ms=checkpoint_after_ms,\nstrategy=strategy,\n)\noptions = persistent_pb2.CreateReq.Options(settings=settings, group_name=group_name)\nif stream is None:  # $all\noptions.all.CopyFrom(\n_build_options_all(\ncommit_position=commit_position,\nprepare_position=prepare_position,\nfrom_revision=from_revision,\nfilter_options=filter_options,\n)\n)\nelse:\noptions.stream.CopyFrom(\n_build_options_stream(stream=stream, from_revision=from_revision)\n)\nrequest = persistent_pb2.CreateReq(options=options)\nresponse = stub.Create(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/persistent/delete/","title":"Delete","text":"<p>Delete persisten subscription.</p>"},{"location":"reference/eventstore_grpc/persistent/delete/#eventstore_grpc.persistent.delete.delete_persistent_subscription","title":"<code>delete_persistent_subscription(stub, group, stream=None)</code>","text":"<p>Deletes a persistent subscription.</p> Source code in <code>src/eventstore_grpc/persistent/delete.py</code> <pre><code>def delete_persistent_subscription(\nstub: persistent_pb2_grpc.PersistentSubscriptionsStub,\ngroup: str,\nstream: Optional[str] = None,\n) -&gt; persistent_pb2.DeleteResp:\n\"\"\"Deletes a persistent subscription.\"\"\"\nrequest = persistent_pb2.DeleteReq()\noptions = persistent_pb2.DeleteReq.Options()\nif stream is not None:\nidentifier = shared_pb2.StreamIdentifier()\nidentifier.stream_name = stream.encode()\noptions.stream_identifier.CopyFrom(identifier)\nelse:  # $all\noptions.all.CopyFrom(shared_pb2.Empty())\noptions.group_name = group\nrequest.options.CopyFrom(options)\nresponse = stub.Delete(request)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/persistent/get_info/","title":"Get info","text":"<p>Get Info about a persistent subscription.</p>"},{"location":"reference/eventstore_grpc/persistent/get_info/#eventstore_grpc.persistent.get_info.get_info","title":"<code>get_info(stub, group_name, stream_name=None, **kwargs)</code>","text":"<p>Gets info about a persistent subscription.</p> Source code in <code>src/eventstore_grpc/persistent/get_info.py</code> <pre><code>def get_info(\nstub: persistent_pb2_grpc.PersistentSubscriptionsStub,\ngroup_name: str,\nstream_name: Optional[str] = None,\n**kwargs,\n) -&gt; persistent_pb2.GetInfoResp:\n\"\"\"Gets info about a persistent subscription.\"\"\"\noptions = persistent_pb2.GetInfoReq.Options(group_name=group_name)\nif stream_name is None:  # $all\noptions.all.CopyFrom(shared_pb2.Empty())\nelse:\noptions.stream_identifier.CopyFrom(\nshared_pb2.StreamIdentifier(stream_name=stream_name.encode())\n)\nrequest = persistent_pb2.GetInfoReq(options=options)\nresponse = stub.GetInfo(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/persistent/list/","title":"List","text":"<p>List persistent subscriptions.</p>"},{"location":"reference/eventstore_grpc/persistent/list/#eventstore_grpc.persistent.list.list_persistent","title":"<code>list_persistent(stub, stream_name=None, list_all=False, **kwargs)</code>","text":"<p>Lists persistent subscriptions.</p> Source code in <code>src/eventstore_grpc/persistent/list.py</code> <pre><code>def list_persistent(\nstub: persistent_pb2_grpc.PersistentSubscriptionsStub,\nstream_name: Optional[str] = None,\nlist_all: bool = False,\n**kwargs,\n) -&gt; persistent_pb2.ReplayParkedResp:\n\"\"\"Lists persistent subscriptions.\"\"\"\noptions = persistent_pb2.ListReq.Options()\nif not list_all:\nstream_option = persistent_pb2.ListReq.StreamOption()\nif stream_name is not None:\nstream_option.stream.CopyFrom(\nshared_pb2.StreamIdentifier(stream_name=stream_name.encode())\n)\nelse:\nstream_option.all.CopyFrom(shared_pb2.Empty())\noptions.list_for_stream.CopyFrom()\nelse:\noptions.list_all_subscriptions.CopyFrom(shared_pb2.Empty())\nrequest = persistent_pb2.ListReq(options=options)\nresponse = stub.ReplayParked(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/persistent/read/","title":"Read","text":"<p>Persistent Subscriptions Operations.</p>"},{"location":"reference/eventstore_grpc/persistent/read/#eventstore_grpc.persistent.read.options_request","title":"<code>options_request(stream, group_name, buffer_size=10)</code>","text":"<p>Returns a persistent subscription options request.</p> Source code in <code>src/eventstore_grpc/persistent/read.py</code> <pre><code>def options_request(\nstream: str, group_name: str, buffer_size: int = 10\n) -&gt; persistent_pb2.ReadReq:\n\"\"\"Returns a persistent subscription options request.\"\"\"\nrequest = persistent_pb2.ReadReq()\noptions = persistent_pb2.ReadReq.Options()\nidentifier = shared_pb2.StreamIdentifier()\nidentifier.stream_name = stream.encode()\nuuid_option = persistent_pb2.ReadReq.Options.UUIDOption()\nuuid_option.string.CopyFrom(shared_pb2.Empty())\noptions.stream_identifier.CopyFrom(identifier)\noptions.group_name = group_name\noptions.buffer_size = buffer_size\noptions.uuid_option.CopyFrom(uuid_option)\nrequest.options.CopyFrom(options)\nreturn request\n</code></pre>"},{"location":"reference/eventstore_grpc/persistent/replay_parked/","title":"Replay parked","text":"<p>Replay parked messages for a persistent subscription.</p>"},{"location":"reference/eventstore_grpc/persistent/replay_parked/#eventstore_grpc.persistent.replay_parked.replay_parked","title":"<code>replay_parked(stub, group_name, stream_name=None, stop_at=None, **kwargs)</code>","text":"<p>Gets info about a persistent subscription.</p> Source code in <code>src/eventstore_grpc/persistent/replay_parked.py</code> <pre><code>def replay_parked(\nstub: persistent_pb2_grpc.PersistentSubscriptionsStub,\ngroup_name: str,\nstream_name: Optional[str] = None,\nstop_at: Optional[int] = None,\n**kwargs,\n) -&gt; persistent_pb2.ReplayParkedResp:\n\"\"\"Gets info about a persistent subscription.\"\"\"\noptions = persistent_pb2.ReplayParkedReq.Options(group_name=group_name)\nif stream_name is None:  # $all\noptions.all.CopyFrom(shared_pb2.Empty())\nelse:\noptions.stream_identifier.CopyFrom(\nshared_pb2.StreamIdentifier(stream_name=stream_name.encode())\n)\nif stop_at is not None:\noptions.stop_at = stop_at\nelse:\noptions.no_limit.CopyFrom(shared_pb2.Empty())\nrequest = persistent_pb2.ReplayParkedReq(options=options)\nresponse = stub.ReplayParked(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/persistent/update/","title":"Update","text":"<p>Update persistent subscription.</p>"},{"location":"reference/eventstore_grpc/persistent/update/#eventstore_grpc.persistent.update.update_persistent_subscription","title":"<code>update_persistent_subscription(stub, group_name, stream=None, resolve_link_to_s=None, from_revision=None, commit_position=None, prepare_position=None, extra_statistics=None, message_timeout_ms=None, checkpoint_after_ms=None, max_retry_count=None, min_checkpoint_count=None, max_checkpoint_count=None, max_subscriber_count=None, live_buffer_size=None, history_buffer_size=None, read_batch_size=None, named_consumer_strategy=None, **kwargs)</code>","text":"<p>Updates a persistent subscription.</p> Source code in <code>src/eventstore_grpc/persistent/update.py</code> <pre><code>def update_persistent_subscription(\nstub: persistent_pb2_grpc.PersistentSubscriptionsStub,\ngroup_name: str | None,\nstream: str | None = None,\nresolve_link_to_s: Optional[bool] = None,\nfrom_revision: Optional[Union[int, str]] = None,\ncommit_position: Optional[int] = None,\nprepare_position: Optional[int] = None,\nextra_statistics: Optional[bool] = None,\nmessage_timeout_ms: Optional[int] = None,\ncheckpoint_after_ms: Optional[int] = None,\nmax_retry_count: Optional[int] = None,\nmin_checkpoint_count: Optional[int] = None,\nmax_checkpoint_count: Optional[int] = None,\nmax_subscriber_count: Optional[int] = None,\nlive_buffer_size: Optional[int] = None,\nhistory_buffer_size: Optional[int] = None,\nread_batch_size: Optional[int] = None,\nnamed_consumer_strategy: Optional[str] = None,\n**kwargs,\n) -&gt; persistent_pb2.UpdateResp:\n\"\"\"Updates a persistent subscription.\"\"\"\nif history_buffer_size is None:\n# TODO: talk with EventStoreDB about this behavior?\nlog.warning(\nf\"If you don't send `history_buffer_size` EventStoreDB will hang indefinitely: forcing it to its default value -&gt; 500\"\n)\nhistory_buffer_size = 500\nsettings = _build_settings(\nresolve_link_to_s=resolve_link_to_s,\nextra_statistics=extra_statistics,\nmessage_timeout_ms=message_timeout_ms,\ncheckpoint_after_ms=checkpoint_after_ms,\nmax_retry_count=max_retry_count,\nmin_checkpoint_count=min_checkpoint_count,\nmax_checkpoint_count=max_checkpoint_count,\nmax_subscriber_count=max_subscriber_count,\nlive_buffer_size=live_buffer_size,\nhistory_buffer_size=history_buffer_size,\nread_batch_size=read_batch_size,\nnamed_consumer_strategy=named_consumer_strategy,\n)\noptions = persistent_pb2.UpdateReq.Options(settings=settings, group_name=group_name)\nif stream is None:  # $all\noptions.all.CopyFrom(\n_build_options_all(\ncommit_position=commit_position,\nprepare_position=prepare_position,\nfrom_revision=from_revision,\n)\n)\nelse:\noptions.stream.CopyFrom(\n_build_options_stream(stream=stream, from_revision=from_revision)\n)\nrequest = persistent_pb2.UpdateReq(options=options)\nresponse = stub.Update(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/projections/__init__/","title":"init","text":""},{"location":"reference/eventstore_grpc/projections/create_continuous/","title":"Create continuous","text":"<p>Create continuous projection.</p>"},{"location":"reference/eventstore_grpc/projections/create_continuous/#eventstore_grpc.projections.create_continuous.create_continuous_projection","title":"<code>create_continuous_projection(stub, name, query, track_emitted_streams=False, **kwargs)</code>","text":"<p>Creates a continuous projection.</p> Source code in <code>src/eventstore_grpc/projections/create_continuous.py</code> <pre><code>def create_continuous_projection(\nstub: projections_pb2_grpc.ProjectionsStub,\nname: str,\nquery: str,\ntrack_emitted_streams: bool = False,\n**kwargs,\n) -&gt; projections_pb2.CreateResp:\n\"\"\"Creates a continuous projection.\"\"\"\nrequest = projections_pb2.CreateReq()\noptions = projections_pb2.CreateReq.Options()\ncontinuous = projections_pb2.CreateReq.Options.Continuous()\ncontinuous.name = name\ncontinuous.track_emitted_streams = track_emitted_streams\noptions.continuous.CopyFrom(continuous)\noptions.query = query\nrequest.options.CopyFrom(options)\nresponse = stub.Create(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/projections/create_one_time/","title":"Create one time","text":"<p>Create one time projection.</p>"},{"location":"reference/eventstore_grpc/projections/create_one_time/#eventstore_grpc.projections.create_one_time.create_one_time_projection","title":"<code>create_one_time_projection(stub, query, track_emitted_streams=False, **kwargs)</code>","text":"<p>Creates a one time projection.</p> Source code in <code>src/eventstore_grpc/projections/create_one_time.py</code> <pre><code>def create_one_time_projection(\nstub: projections_pb2_grpc.ProjectionsStub,\nquery: str,\ntrack_emitted_streams: bool = False,\n**kwargs,\n) -&gt; projections_pb2.CreateResp:\n\"\"\"Creates a one time projection.\"\"\"\nrequest = projections_pb2.CreateReq()\noptions = projections_pb2.CreateReq.Options()\noptions.query = query\noptions.one_time.CopyFrom(shared_pb2.Empty())\nrequest.options.CopyFrom(options)\nresponse = stub.Create(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/projections/create_transient/","title":"Create transient","text":"<p>Create transient projection.</p>"},{"location":"reference/eventstore_grpc/projections/create_transient/#eventstore_grpc.projections.create_transient.create_transient_projection","title":"<code>create_transient_projection(stub, name, query, **kwargs)</code>","text":"<p>Creates a one time projection.</p> Source code in <code>src/eventstore_grpc/projections/create_transient.py</code> <pre><code>def create_transient_projection(\nstub: projections_pb2_grpc.ProjectionsStub,\nname: str,\nquery: str,\n**kwargs,\n) -&gt; projections_pb2.CreateResp:\n\"\"\"Creates a one time projection.\"\"\"\nrequest = projections_pb2.CreateReq()\noptions = projections_pb2.CreateReq.Options()\ntransient = projections_pb2.CreateReq.Options.Transient()\ntransient.name = name\noptions.transient.CopyFrom(transient)\noptions.query = query\nrequest.options.CopyFrom(options)\nresponse = stub.Create(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/projections/delete/","title":"Delete","text":"<p>Delete projections.</p>"},{"location":"reference/eventstore_grpc/projections/delete/#eventstore_grpc.projections.delete.delete_projection","title":"<code>delete_projection(stub, name, delete_emitted_streams=True, delete_state_stream=True, delete_checkpoint_stream=True, **kwargs)</code>","text":"<p>Deletes a projection.</p> Source code in <code>src/eventstore_grpc/projections/delete.py</code> <pre><code>def delete_projection(\nstub: projections_pb2_grpc.ProjectionsStub,\nname: str,\ndelete_emitted_streams: bool = True,\ndelete_state_stream: bool = True,\ndelete_checkpoint_stream: bool = True,\n**kwargs,\n) -&gt; projections_pb2.DeleteResp:\n\"\"\"Deletes a projection.\"\"\"\nrequest = projections_pb2.DeleteReq()\noptions = projections_pb2.DeleteReq.Options()\noptions.name = name\noptions.delete_emitted_streams = delete_emitted_streams\noptions.delete_state_stream = delete_state_stream\noptions.delete_checkpoint_stream = delete_checkpoint_stream\nrequest.options.CopyFrom(options)\nresponse = stub.Delete(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/projections/disable/","title":"Disable","text":"<p>Disable projections.</p>"},{"location":"reference/eventstore_grpc/projections/disable/#eventstore_grpc.projections.disable.disable_projection","title":"<code>disable_projection(stub, name, write_checkpoint=True, **kwargs)</code>","text":"<p>Disables a projection.</p> Source code in <code>src/eventstore_grpc/projections/disable.py</code> <pre><code>def disable_projection(\nstub: projections_pb2_grpc.ProjectionsStub,\nname: str,\nwrite_checkpoint: bool = True,\n**kwargs\n) -&gt; projections_pb2.DisableResp:\n\"\"\"Disables a projection.\"\"\"\nrequest = projections_pb2.DisableReq()\noptions = projections_pb2.DisableReq.Options()\noptions.name = name\noptions.write_checkpoint = write_checkpoint\nrequest.options.CopyFrom(options)\nresponse = stub.Disable(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/projections/enable/","title":"Enable","text":"<p>Enable projections.</p>"},{"location":"reference/eventstore_grpc/projections/enable/#eventstore_grpc.projections.enable.enable_projection","title":"<code>enable_projection(stub, name, **kwargs)</code>","text":"<p>Enables a projection.</p> Source code in <code>src/eventstore_grpc/projections/enable.py</code> <pre><code>def enable_projection(\nstub: projections_pb2_grpc.ProjectionsStub, name: str, **kwargs\n) -&gt; projections_pb2.DisableResp:\n\"\"\"Enables a projection.\"\"\"\nrequest = projections_pb2.EnableReq()\noptions = projections_pb2.EnableReq.Options()\noptions.name = name\nrequest.options.CopyFrom(options)\nresponse = stub.Enable(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/projections/list/","title":"List","text":"<p>List projections.</p>"},{"location":"reference/eventstore_grpc/projections/list/#eventstore_grpc.projections.list.list_continuous_projections","title":"<code>list_continuous_projections(stub, **kwargs)</code>","text":"<p>Lists continuous projections.</p> Source code in <code>src/eventstore_grpc/projections/list.py</code> <pre><code>def list_continuous_projections(\nstub: projections_pb2_grpc.ProjectionsStub, **kwargs\n) -&gt; Iterable[projections_pb2.StatisticsResp]:\n\"\"\"Lists continuous projections.\"\"\"\nrequest = projections_pb2.StatisticsReq()\noptions = projections_pb2.StatisticsReq.Options()\noptions.continuous.CopyFrom(shared_pb2.Empty())\nrequest.options.CopyFrom(options)\nresponse = stub.Statistics(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/projections/list/#eventstore_grpc.projections.list.list_one_time_projections","title":"<code>list_one_time_projections(stub, **kwargs)</code>","text":"<p>Lists one time projections.</p> Source code in <code>src/eventstore_grpc/projections/list.py</code> <pre><code>def list_one_time_projections(\nstub: projections_pb2_grpc.ProjectionsStub, **kwargs\n) -&gt; Iterable[projections_pb2.StatisticsResp]:\n\"\"\"Lists one time projections.\"\"\"\nrequest = projections_pb2.StatisticsReq()\noptions = projections_pb2.StatisticsReq.Options()\noptions.one_time.CopyFrom(shared_pb2.Empty())\nrequest.options.CopyFrom(options)\nresponse = stub.Statistics(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/projections/list/#eventstore_grpc.projections.list.list_transient_projections","title":"<code>list_transient_projections(stub, **kwargs)</code>","text":"<p>Lists transient projections.</p> Source code in <code>src/eventstore_grpc/projections/list.py</code> <pre><code>def list_transient_projections(\nstub: projections_pb2_grpc.ProjectionsStub, **kwargs\n) -&gt; Iterable[projections_pb2.StatisticsResp]:\n\"\"\"Lists transient projections.\"\"\"\nrequest = projections_pb2.StatisticsReq()\noptions = projections_pb2.StatisticsReq.Options()\noptions.transient.CopyFrom(shared_pb2.Empty())\nrequest.options.CopyFrom(options)\nresponse = stub.Statistics(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/projections/reset/","title":"Reset","text":"<p>Reset projections.</p>"},{"location":"reference/eventstore_grpc/projections/reset/#eventstore_grpc.projections.reset.reset_projection","title":"<code>reset_projection(stub, name, write_checkpoint=True, **kwargs)</code>","text":"<p>Resets a projection.</p> Source code in <code>src/eventstore_grpc/projections/reset.py</code> <pre><code>def reset_projection(\nstub: projections_pb2_grpc.ProjectionsStub,\nname: str,\nwrite_checkpoint: bool = True,\n**kwargs\n) -&gt; projections_pb2.ResetResp:\n\"\"\"Resets a projection.\"\"\"\nrequest = projections_pb2.ResetReq()\noptions = projections_pb2.ResetReq.Options()\noptions.name = name\noptions.write_checkpoint = write_checkpoint\nrequest.options.CopyFrom(options)\nresponse = stub.Reset(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/projections/restart/","title":"Restart","text":"<p>Restart projections.</p>"},{"location":"reference/eventstore_grpc/projections/restart/#eventstore_grpc.projections.restart.restart_projections_subsystem","title":"<code>restart_projections_subsystem(stub, **kwargs)</code>","text":"<p>Restart projections subsystem.</p> Source code in <code>src/eventstore_grpc/projections/restart.py</code> <pre><code>def restart_projections_subsystem(\nstub: projections_pb2_grpc.ProjectionsStub, **kwargs\n) -&gt; shared_pb2.Empty:\n\"\"\"Restart projections subsystem.\"\"\"\nreturn stub.RestartSubsystem(shared_pb2.Empty(), **kwargs)\n</code></pre>"},{"location":"reference/eventstore_grpc/projections/result/","title":"Result","text":"<p>Get projection results.</p>"},{"location":"reference/eventstore_grpc/projections/result/#eventstore_grpc.projections.result.get_projection_result","title":"<code>get_projection_result(stub, name, from_partition=None, **kwargs)</code>","text":"<p>Gets a projection result.</p> Source code in <code>src/eventstore_grpc/projections/result.py</code> <pre><code>def get_projection_result(\nstub: projections_pb2_grpc.ProjectionsStub,\nname: str,\nfrom_partition: str = None,\n**kwargs\n) -&gt; projections_pb2.ResultResp:\n\"\"\"Gets a projection result.\"\"\"\nrequest = projections_pb2.ResultReq()\noptions = projections_pb2.ResultReq.Options()\noptions.name = name\noptions.partition = from_partition or \"\"\nrequest.options.CopyFrom(options)\nresponse = stub.Result(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/projections/state/","title":"State","text":"<p>Get projection states.</p>"},{"location":"reference/eventstore_grpc/projections/state/#eventstore_grpc.projections.state.get_projection_state","title":"<code>get_projection_state(stub, name, **kwargs)</code>","text":"<p>Gets a projection's state.</p> Source code in <code>src/eventstore_grpc/projections/state.py</code> <pre><code>def get_projection_state(\nstub: projections_pb2_grpc.ProjectionsStub, name: str, **kwargs\n) -&gt; projections_pb2.StateResp:\n\"\"\"Gets a projection's state.\"\"\"\nrequest = projections_pb2.StateReq()\noptions = projections_pb2.StateReq.Options()\noptions.name = name\nrequest.options.CopyFrom(options)\nresponse = stub.State(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/projections/statistics/","title":"Statistics","text":"<p>Get projections statistics.</p>"},{"location":"reference/eventstore_grpc/projections/statistics/#eventstore_grpc.projections.statistics.get_projection_statistics","title":"<code>get_projection_statistics(stub, name, **kwargs)</code>","text":"<p>Get projection statistics.</p> Source code in <code>src/eventstore_grpc/projections/statistics.py</code> <pre><code>def get_projection_statistics(\nstub: projections_pb2_grpc.ProjectionsStub, name: str, **kwargs\n) -&gt; Iterable[projections_pb2.StatisticsResp]:\n\"\"\"Get projection statistics.\"\"\"\nrequest = projections_pb2.StatisticsReq()\noptions = projections_pb2.StatisticsReq.Options()\noptions.name = name\nrequest.options.CopyFrom(options)\nresponse = stub.Statistics(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/projections/update/","title":"Update","text":"<p>Update projections.</p>"},{"location":"reference/eventstore_grpc/projections/update/#eventstore_grpc.projections.update.update_projection","title":"<code>update_projection(stub, name, query, track_emitted_streams=None, **kwargs)</code>","text":"<p>Updates a projection.</p> Source code in <code>src/eventstore_grpc/projections/update.py</code> <pre><code>def update_projection(\nstub: projections_pb2_grpc.ProjectionsStub,\nname: str,\nquery: str,\ntrack_emitted_streams: Optional[bool] = None,\n**kwargs,\n) -&gt; projections_pb2.UpdateResp:\n\"\"\"Updates a projection.\"\"\"\nrequest = projections_pb2.UpdateReq()\noptions = projections_pb2.UpdateReq.Options()\noptions.name = name\noptions.query = query\nif track_emitted_streams is None:\noptions.no_emit_options.CopyFrom(shared_pb2.Empty())\nelse:\noptions.emit_enabled = track_emitted_streams\nrequest.options.CopyFrom(options)\nresponse = stub.Update(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/streams/__init__/","title":"init","text":""},{"location":"reference/eventstore_grpc/streams/append/","title":"Append","text":"<p>Append Events to Streams.</p>"},{"location":"reference/eventstore_grpc/streams/append/#eventstore_grpc.streams.append.WrongExpectedVersionError","title":"<code>WrongExpectedVersionError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Occurs when an event is appended with the wrong expected version.</p> Source code in <code>src/eventstore_grpc/streams/append.py</code> <pre><code>class WrongExpectedVersionError(Exception):\n\"\"\"Occurs when an event is appended with the wrong expected version.\"\"\"\ndef __init__(self, expected, current, grpc_response):\nself.expected = expected\nself.current = current\nself.grpc_response = grpc_response\nself.msg = f\"Current version ({current!s}) != Expected version ({expected!s})\"\nsuper(Exception, self).__init__(self.msg)\n</code></pre>"},{"location":"reference/eventstore_grpc/streams/append/#eventstore_grpc.streams.append.append_to_stream","title":"<code>append_to_stream(stub, stream, expected_version, events, user_credentials, **kwargs)</code>","text":"<p>Appends an Event to an Event Stream.</p> <p>Write one or more events to a stream, atomically. You do this by appending the events to the stream in one operation, or by using transations.</p> <p>Note that sending events to a non-existing stream, implicitly creates the stream.</p> <p>It is possible to make an optimistic concurrency check during the write by specifying the version at which you expect the stream to be.</p> <p>Identical write operations are idempotent if the optimistic concurrency check is not disabled.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>str</code> <p>A string identifying the stream to which to append.</p> required <code>expected_version</code> <code>Union[str, int]</code> <p>the version at which you expect the stream to be in order that an optimistic concurrency check can be performed. This should either be a positive integer or a string, with possible values being \"NO_STREAM\" or \"EMPTY_STREAM\", or \"ANY\" (to disable the check).</p> required <code>events</code> <code>Union[EventData, List[EventData]]</code> <p>event or list of events to append.</p> required <code>user_credentials</code> <code>UserCredentials | None</code> <p>specify the user on behalf whom write will be executed.</p> required Source code in <code>src/eventstore_grpc/streams/append.py</code> <pre><code>def append_to_stream(\nstub: streams_pb2_grpc.StreamsStub,\nstream: str,\nexpected_version: Union[str, int],\nevents: Union[EventData, List[EventData]],\nuser_credentials: UserCredentials | None,  # TODO: remove?\n**kwargs,\n) -&gt; streams_pb2.AppendResp:\n\"\"\"Appends an Event to an Event Stream.\n    Write one or more events to a stream, atomically. You do this by appending\n    the events to the stream in one operation, or by using transations.\n    Note that sending events to a non-existing stream, implicitly creates the stream.\n    It is possible to make an optimistic concurrency check during the write by\n    specifying the version at which you expect the stream to be.\n    Identical write operations are idempotent if the optimistic concurrency check is\n    not disabled.\n    Args:\n        stream: A string identifying the stream to which to append.\n        expected_version: the version at which you expect the stream to be in order\n            that an optimistic concurrency check can be performed. This should either\n            be a positive integer or a string, with possible values being \"NO_STREAM\"\n            or \"EMPTY_STREAM\", or \"ANY\" (to disable the check).\n        events: event or list of events to append.\n        user_credentials: specify the user on behalf whom write will be executed.\n    \"\"\"\nrequest_stream = build_request_stream(stream, expected_version, events)\nresponse = stub.Append(request_stream, **kwargs)\nif response.WhichOneof(\"result\") == constants.WRONG_EXPECTED_VERSION:\n# Explicity raise an error in this case.\nhandle_wrong_expected_version(response)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/streams/append/#eventstore_grpc.streams.append.build_options","title":"<code>build_options(stream, expected_version=None)</code>","text":"<p>Builds AppendReq Options.</p> Source code in <code>src/eventstore_grpc/streams/append.py</code> <pre><code>def build_options(\nstream: str,\nexpected_version: Union[str, int] = None,\n) -&gt; streams_pb2.AppendReq.Options:\n\"\"\"Builds AppendReq Options.\"\"\"\noptions = streams_pb2.AppendReq.Options()\nstream_identifier = shared_pb2.StreamIdentifier()\nstream_identifier.stream_name = stream.encode()\nif isinstance(expected_version, int):\noptions.revision = expected_version\nelif expected_version == constants.NO_STREAM:\noptions.no_stream.CopyFrom(shared_pb2.Empty())\nelif expected_version == constants.ANY:\noptions.any.CopyFrom(shared_pb2.Empty())\nelif expected_version == constants.STREAM_EXISTS:\noptions.stream_exists.CopyFrom(shared_pb2.Empty())\noptions.stream_identifier.CopyFrom(stream_identifier)\nreturn options\n</code></pre>"},{"location":"reference/eventstore_grpc/streams/append/#eventstore_grpc.streams.append.build_options_request","title":"<code>build_options_request(stream, expected_version)</code>","text":"<p>Builds an Options message for AppendReq.</p> Source code in <code>src/eventstore_grpc/streams/append.py</code> <pre><code>def build_options_request(\nstream: str, expected_version: Union[str, int]\n) -&gt; streams_pb2.AppendReq:\n\"\"\"Builds an Options message for AppendReq.\"\"\"\nrequest = streams_pb2.AppendReq()\noptions = build_options(stream, expected_version)\nrequest.options.CopyFrom(options)\nreturn request\n</code></pre>"},{"location":"reference/eventstore_grpc/streams/append/#eventstore_grpc.streams.append.build_proposed_message_request","title":"<code>build_proposed_message_request(event)</code>","text":"<p>Builds AppendReq Proposed Message.</p> Source code in <code>src/eventstore_grpc/streams/append.py</code> <pre><code>def build_proposed_message_request(event: EventData):\n\"\"\"Builds AppendReq Proposed Message.\"\"\"\nrequest = streams_pb2.AppendReq()\nmessage = streams_pb2.AppendReq.ProposedMessage()\nmessage.id.string = str(getattr(event, \"event_id\", uuid.uuid4()))\nmessage.metadata[\"type\"] = event.type\nmessage.metadata[\"content-type\"] = event.data_content_type\nmessage.data = event.serialized_data\nmessage.custom_metadata = event.serialized_metadata\nrequest.proposed_message.CopyFrom(message)\nreturn request\n</code></pre>"},{"location":"reference/eventstore_grpc/streams/append/#eventstore_grpc.streams.append.build_request_stream","title":"<code>build_request_stream(stream, expected_version, events)</code>","text":"<p>Builds the AppendReq stream.</p> Source code in <code>src/eventstore_grpc/streams/append.py</code> <pre><code>def build_request_stream(\nstream: str,\nexpected_version: Union[str, int],\nevents: Union[EventData, List[EventData]],\n) -&gt; Iterator[streams_pb2.AppendReq]:\n\"\"\"Builds the AppendReq stream.\"\"\"\nif not isinstance(events, list):\nevents = [events]\noptions = build_options_request(stream, expected_version)\nproposed_messages = [build_proposed_message_request(elm) for elm in events]\nrequest_stream = [options, *proposed_messages]\nreturn iter(request_stream)\n</code></pre>"},{"location":"reference/eventstore_grpc/streams/append/#eventstore_grpc.streams.append.handle_wrong_expected_version","title":"<code>handle_wrong_expected_version(message)</code>","text":"<p>Handles append error.</p> Source code in <code>src/eventstore_grpc/streams/append.py</code> <pre><code>def handle_wrong_expected_version(message: streams_pb2.AppendResp):\n\"\"\"Handles append error.\"\"\"\nexpected_revision_option = message.wrong_expected_version.WhichOneof(\n\"expected_revision_option\"\n)\nexpected = None\nif expected_revision_option == \"expected_revision\":\nexpected = message.wrong_expected_version.expected_revision\nelif expected_revision_option == \"expected_any\":\nexpected = constants.ANY\nelif expected_revision_option == \"expected_stream_exists\":\nexpected = constants.STREAM_EXISTS\nelif expected_revision_option == \"expected_no_stream\":\nexpected = constants.NO_STREAM\ncurrent_revision_option = message.wrong_expected_version.WhichOneof(\n\"current_revision_option\"\n)\ncurrent = None\nif current_revision_option == \"current_revision\":\ncurrent = message.wrong_expected_version.current_revision\nelif current_revision_option == \"current_no_stream\":\ncurrent = constants.NO_STREAM\nraise WrongExpectedVersionError(\nexpected=expected, current=current, grpc_response=message\n)\n</code></pre>"},{"location":"reference/eventstore_grpc/streams/delete/","title":"Delete","text":"<p>Streams Delete requests.</p>"},{"location":"reference/eventstore_grpc/streams/delete/#eventstore_grpc.streams.delete.delete_stream","title":"<code>delete_stream(stub, stream, expected_version, **kwargs)</code>","text":"<p>Deletes a stream.</p> Source code in <code>src/eventstore_grpc/streams/delete.py</code> <pre><code>def delete_stream(\nstub: streams_pb2_grpc.StreamsStub,\nstream: str,\nexpected_version: Union[str, int],\n**kwargs\n) -&gt; streams_pb2.DeleteResp:\n\"\"\"Deletes a stream.\"\"\"\nrequest = streams_pb2.DeleteReq()\noptions = streams_pb2.DeleteReq.Options()\nstream_identifier = shared_pb2.StreamIdentifier()\nstream_identifier.stream_name = stream.encode()\nif expected_version == constants.NO_STREAM:\noptions.no_stream.CopyFrom(shared_pb2.Empty())\nelif expected_version == constants.ANY:\noptions.any.CopyFrom(shared_pb2.Empty())\nelif expected_version == constants.STREAM_EXISTS:\noptions.stream_exists.CopyFrom(shared_pb2.Empty())\nelif isinstance(expected_version, int):\noptions.stream_exists = expected_version\noptions.stream_identifier.CopyFrom(stream_identifier)\nrequest.options.CopyFrom(options)\nresponse = stub.Delete(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/streams/read/","title":"Read","text":"<p>Read Events from Streams.</p>"},{"location":"reference/eventstore_grpc/streams/read/#eventstore_grpc.streams.read.read_from_stream","title":"<code>read_from_stream(stub, stream, count, options, **kwargs)</code>","text":"<p>Reads events from an Event Stream.</p> <p>The simplest way to read a stream forwards is to supply a stream name, direction and revision to start from. This can either be a stream position or an unsigned 64 big integer. This will return an iterable yielding events from the stream.</p> <p>There are a number of additional arguments you can provide when reading a stream:</p> <ul> <li><code>max_count</code>: passing in the max count allows you to limit the number of events     that returned.</li> <li><code>resolve_link_to_pos</code>: when using projections to create new events you can set     whether the generated events are pointers to existing events. Setting this     value to true will tell EventStoreDB to returne the event as well as the event     linking to it.</li> <li><code>configure_operation_options</code>: this argument is generic setting class for all     operations that can be set on all operations executed against EventStoreDB. (??)</li> <li><code>user_credentials</code>: the credentials used to read the data can be supplied. To be     used by the subscription as follows. This will override the default     credentials set on the connection.</li> </ul>"},{"location":"reference/eventstore_grpc/streams/read/#eventstore_grpc.streams.read.read_from_stream--reading-from-a-revision","title":"Reading from a revision.","text":"<p>As well as providing a <code>StreamPosition</code> you can also provide a stream revision in the form of an unsigned 64 big integer.</p>"},{"location":"reference/eventstore_grpc/streams/read/#eventstore_grpc.streams.read.read_from_stream--reading-backwards","title":"Reading backwards.","text":"<p>As well as being able to read a stream forwards, you can also go backwards. When reading backwards is the stream position will have to be set to the end if you want to read all the events.</p> <p>Tip: You can use reading backwards to find the last position in the stream. Just read backwards one event and get the position.</p>"},{"location":"reference/eventstore_grpc/streams/read/#eventstore_grpc.streams.read.read_from_stream--checking-for-stream-presence","title":"Checking for stream presence.","text":"<p>Reading a stream returns a ReadStreamResult containing a ReadState. This property can have the value StreamNotFound and Ok. It is important to check the value of this field before attempting to iterate an empty stream as it will throw an exception.</p> Source code in <code>src/eventstore_grpc/streams/read.py</code> <pre><code>def read_from_stream(\nstub: streams_pb2_grpc.StreamsStub,\nstream: str,\ncount: int | None,\noptions: Dict,  # TODO: use from_revision as a parameter.\n**kwargs,\n) -&gt; Iterator[streams_pb2.ReadResp]:\n\"\"\"Reads events from an Event Stream.\n    The simplest way to read a stream forwards is to supply a stream name, direction\n    and revision to start from. This can either be a stream position or an unsigned\n    64 big integer. This will return an iterable yielding events from the stream.\n    There are a number of additional arguments you can provide when reading a stream:\n    * `max_count`: passing in the max count allows you to limit the number of events\n        that returned.\n    * `resolve_link_to_pos`: when using projections to create new events you can set\n        whether the generated events are pointers to existing events. Setting this\n        value to true will tell EventStoreDB to returne the event as well as the event\n        linking to it.\n    * `configure_operation_options`: this argument is generic setting class for all\n        operations that can be set on all operations executed against EventStoreDB. (??)\n    * `user_credentials`: the credentials used to read the data can be supplied. To be\n        used by the subscription as follows. This will override the default\n        credentials set on the connection.\n    ### Reading from a revision.\n    As well as providing a `StreamPosition` you can also provide a stream revision\n    in the form of an unsigned 64 big integer.\n    ### Reading backwards.\n    As well as being able to read a stream forwards, you can also go backwards. When\n    reading backwards is the stream position will have to be set to the end if you\n    want to read all the events.\n    &gt; Tip: You can use reading backwards to find the last position in the stream. Just\n    &gt; read backwards one event and get the position.\n    ### Checking for stream presence.\n    Reading a stream returns a ReadStreamResult containing a ReadState. This property\n    can have the value StreamNotFound and Ok. It is important to check the value of\n    this field before attempting to iterate an empty stream as it will throw an\n    exception.\n    \"\"\"\nrequest = streams_pb2.ReadReq()\nreq_options = streams_pb2.ReadReq.Options()\nidentifier = shared_pb2.StreamIdentifier()\nidentifier.stream_name = stream.encode()\nuuid_option = streams_pb2.ReadReq.Options.UUIDOption()\nuuid_option.string.CopyFrom(shared_pb2.Empty())\nstream_options = streams_pb2.ReadReq.Options.StreamOptions()\nstream_options.stream_identifier.CopyFrom(identifier)\nfrom_revision = options.get(\"from_revision\")\nif from_revision == constants.START:\nstream_options.start.CopyFrom(shared_pb2.Empty())\nelif from_revision == constants.END:\nstream_options.end.CopyFrom(shared_pb2.Empty())\nelif isinstance(from_revision, int):\nstream_options.revision = from_revision\nreq_options.stream.CopyFrom(stream_options)\nreq_options.uuid_option.CopyFrom(uuid_option)\nresolve_links = options.get(\"resolve_link_to_s\", False)\nreq_options.resolve_links = resolve_links\nreq_options.count = count or sys.maxsize\nreq_options.no_filter.CopyFrom(shared_pb2.Empty())\ndefault_direction = \"backwards\" if from_revision == constants.END else \"forwards\"\ndirection = options.get(\"direction\", default_direction)\nif direction.lower() == \"forwards\":\nreq_options.read_direction = streams_pb2.ReadReq.Options.ReadDirection.Forwards\nelif direction.lower() == \"backwards\":\nreq_options.read_direction = streams_pb2.ReadReq.Options.ReadDirection.Backwards\nrequest.options.CopyFrom(req_options)\nresponse = stub.Read(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/streams/subscribe/","title":"Subscribe","text":"<p>Non-persistent stream subscription operations.</p>"},{"location":"reference/eventstore_grpc/streams/subscribe/#eventstore_grpc.streams.subscribe.get_all_subscription_request","title":"<code>get_all_subscription_request(from_position=constants.START, resolve_link_to_s=False, filters=None)</code>","text":"<p>Returns a streams_pb2.ReadReq configured for subscription operations for the \"$all\" stream.</p> Source code in <code>src/eventstore_grpc/streams/subscribe.py</code> <pre><code>def get_all_subscription_request(\nfrom_position: Union[Dict[str, int], str] = constants.START,\nresolve_link_to_s: bool = False,\nfilters: Dict = None,\n) -&gt; streams_pb2.ReadReq:\n\"\"\"Returns a streams_pb2.ReadReq configured for subscription operations for the \"$all\" stream.\"\"\"\nrequest = streams_pb2.ReadReq()\noptions = streams_pb2.ReadReq.Options()\nuuid_option = streams_pb2.ReadReq.Options.UUIDOption()\nuuid_option.string.CopyFrom(shared_pb2.Empty())\nall_options = streams_pb2.ReadReq.Options.AllOptions()\nif isinstance(from_position, dict):\ngrpc_pos = streams_pb2.ReadReq.Options.Position()\ngrpc_pos.commit_position = from_position[\"commit_position\"]\ngrpc_pos.prepare_position = from_position[\"prepare_position\"]\nall_options.position.CopyFrom(grpc_pos)\nelif from_position == constants.START:\nall_options.start.CopyFrom(shared_pb2.Empty())\nelif from_position == constants.END:\nall_options.end.CopyFrom(shared_pb2.Empty())\noptions.all.CopyFrom(all_options)\noptions.resolve_links = resolve_link_to_s\noptions.subscription.CopyFrom(streams_pb2.ReadReq.Options.SubscriptionOptions())\noptions.uuid_option.CopyFrom(uuid_option)\nif filters is not None:\nexpr = streams_pb2.ReadReq.Options.FilterOptions.Expression()\nif \"prefixes\" in filters:\nfor elm in filters[\"prefixes\"]:\nexpr.prefix.append(elm)\nif \"regex\" in filters:\nexpr.regex = filters[\"regex\"]\nfilter_options = streams_pb2.ReadReq.Options.FilterOptions()\nfilter_on = filters.get(\"filter_on\")\nif filter_on == \"STREAM_NAME\":\nfilter_options.stream_identifier.CopyFrom(expr)\nelif filter_on == \"EVENT_TYPE\":\nfilter_options.event_type.CopyFrom(expr)\nmax_search_window = filters.get(\"max_search_window\")\nif max_search_window is not None:\nif max_search_window &lt;= 0:\nraise ValueError(\"CheckpointInterval must be greater than 0.\")\nfilter_options.max = max_search_window\nelse:\nfilter_options.count.CopyFrom(shared_pb2.Empty())\ncheckpoint_interval = filters.get(\"checkpoint_interval\")\nif checkpoint_interval is None or checkpoint_interval &lt;= 0:\nraise ValueError(\"CheckpointInterval must be greater than 0.\")\nfilter_options.checkpointIntervalMultiplier = checkpoint_interval\noptions.filter.CopyFrom(filter_options)\nelse:\noptions.no_filter.CopyFrom(shared_pb2.Empty())\nrequest.options.CopyFrom(options)\nreturn request\n</code></pre>"},{"location":"reference/eventstore_grpc/streams/subscribe/#eventstore_grpc.streams.subscribe.get_stream_subscription_request","title":"<code>get_stream_subscription_request(stream, from_revision=constants.START, resolve_link_to_s=False)</code>","text":"<p>Returns a streams_pb2.ReadReq configured for subscription operations for a generic stream.</p> Source code in <code>src/eventstore_grpc/streams/subscribe.py</code> <pre><code>def get_stream_subscription_request(\nstream: str,\nfrom_revision: Union[str, int] = constants.START,\nresolve_link_to_s: bool = False,\n) -&gt; streams_pb2.ReadReq:\n\"\"\"Returns a streams_pb2.ReadReq configured for subscription operations for a generic stream.\"\"\"\nrequest = streams_pb2.ReadReq()\noptions = streams_pb2.ReadReq.Options()\nidentifier = shared_pb2.StreamIdentifier()\nidentifier.stream_name = stream.encode()\nuuid_option = streams_pb2.ReadReq.Options.UUIDOption()\nuuid_option.string.CopyFrom(shared_pb2.Empty())\nstream_options = streams_pb2.ReadReq.Options.StreamOptions()\nstream_options.stream_identifier.CopyFrom(identifier)\nif isinstance(from_revision, int):\nstream_options.revision = from_revision\nelif from_revision == constants.START:\nstream_options.start.CopyFrom(shared_pb2.Empty())\nelif from_revision == constants.END:\nstream_options.end.CopyFrom(shared_pb2.Empty())\noptions.stream.CopyFrom(stream_options)\noptions.resolve_links = resolve_link_to_s\noptions.subscription.CopyFrom(streams_pb2.ReadReq.Options.SubscriptionOptions())\noptions.uuid_option.CopyFrom(uuid_option)\noptions.no_filter.CopyFrom(shared_pb2.Empty())\nrequest.options.CopyFrom(options)\nreturn request\n</code></pre>"},{"location":"reference/eventstore_grpc/streams/subscribe/#eventstore_grpc.streams.subscribe.subscribe_to_all","title":"<code>subscribe_to_all(stub, from_position=constants.START, resolve_link_to_s=False, filters=None, **kwargs)</code>","text":"<p>Subscribes to $all stream. Returns an object that can be iterated on to get events.</p> Source code in <code>src/eventstore_grpc/streams/subscribe.py</code> <pre><code>def subscribe_to_all(\nstub: streams_pb2_grpc.StreamsStub,\nfrom_position: Union[Dict[str, int], str] = constants.START,\nresolve_link_to_s: bool = False,\nfilters: Dict = None,\n**kwargs,\n) -&gt; Iterable[streams_pb2.ReadResp]:\n\"\"\"Subscribes to $all stream. Returns an object that can be iterated on to get events.\"\"\"\nrequest = get_all_subscription_request(\nfrom_position=from_position,\nresolve_link_to_s=resolve_link_to_s,\nfilters=filters,\n)\nresponse = stub.Read(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/streams/subscribe/#eventstore_grpc.streams.subscribe.subscribe_to_stream","title":"<code>subscribe_to_stream(stub, stream, from_revision=constants.START, resolve_link_to_s=False, **kwargs)</code>","text":"<p>Subscribes to stream. Returns an object that can be iterated on to get events.</p> Source code in <code>src/eventstore_grpc/streams/subscribe.py</code> <pre><code>def subscribe_to_stream(\nstub: streams_pb2_grpc.StreamsStub,\nstream: str,\nfrom_revision: Union[str, int] = constants.START,\nresolve_link_to_s: bool = False,\n**kwargs,\n) -&gt; Iterable[streams_pb2.ReadResp]:\n\"\"\"Subscribes to stream. Returns an object that can be iterated on to get events.\"\"\"\nrequest = get_stream_subscription_request(\nstream=stream, from_revision=from_revision, resolve_link_to_s=resolve_link_to_s\n)\nresponse = stub.Read(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/streams/tombstone/","title":"Tombstone","text":"<p>Tombstone stream.</p>"},{"location":"reference/eventstore_grpc/streams/tombstone/#eventstore_grpc.streams.tombstone.tombstone_stream","title":"<code>tombstone_stream(stub, stream, expected_version, **kwargs)</code>","text":"<p>Tombstone.</p> Source code in <code>src/eventstore_grpc/streams/tombstone.py</code> <pre><code>def tombstone_stream(\nstub: streams_pb2_grpc.StreamsStub,\nstream: str,\nexpected_version: Union[int, str],\n**kwargs,\n):\n\"\"\"Tombstone.\"\"\"\nrequest = streams_pb2.TombstoneReq()\noptions = streams_pb2.TombstoneReq.Options()\noptions.stream_identifier.CopyFrom(\nshared_pb2.StreamIdentifier(stream_name=stream.encode(\"UTF-8\"))\n)\nif expected_version == constants.ANY:\noptions.any.CopyFrom(shared_pb2.Empty())\nelif expected_version == constants.NO_STREAM:\noptions.no_stream.CopyFrom(shared_pb2.Empty())\nelif expected_version == constants.STREAM_EXISTS:\noptions.stream_exists.CopyFrom(shared_pb2.Empty())\nrequest.options.CopyFrom(options)\nresponse = stub.Tombstone(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/subscriptions/__init__/","title":"init","text":""},{"location":"reference/eventstore_grpc/subscriptions/requests_stream/","title":"Requests stream","text":"<p>Requests Streaming Iterator.</p>"},{"location":"reference/eventstore_grpc/subscriptions/requests_stream/#eventstore_grpc.subscriptions.requests_stream.RequestsStream","title":"<code>RequestsStream</code>","text":"<p>RequestStream.</p> Source code in <code>src/eventstore_grpc/subscriptions/requests_stream.py</code> <pre><code>class RequestsStream:\n\"\"\"RequestStream.\"\"\"\n_lock = threading.RLock()\ndef __init__(\nself,\nhandler: Optional[Callable] = None,\nqueue: Optional[Iterable] = None,\npersistent: bool = False,\ntimeout: int = 5,\n):\nself._handle_task = handler\nself._tasks: q.Queue = q.Queue()\nself._queue: q.Queue = q.Queue()\nif queue is not None:\nfor request in queue:\nself._queue.put(request)\nself._results: list = []\nself._persistent = persistent\nself._timeout = timeout\nself._stop = threading.Event()\ndef __iter__(self):\nreturn self  # pragma: nocover\ndef __next__(self):\nnext_element = None\nwhile next_element is None:\ntry:\nnext_element = self._queue.get(block=True, timeout=self._timeout)\nexcept Exception:\nif self._stop.is_set():\nlog.info(\"\\033[38;5;196mStopping requests streaming.\\033[0m\")\nraise StopIteration\nself._queue.task_done()\nlog.debug(f\"\\033[38;5;45m---- to server ---&gt;\\033[0m\")\nlog.debug(f\"\\033[38;5;45m{next_element}\\033[0m\")\nlog.debug(\"\\033[38;5;45m&lt;-------------------\\033[0m\")\nreturn next_element\ndef handle_task(self, task):\nlog.debug(\"\\033[38;5;79m&lt;---- from server --\\033[0m\")\nlog.debug(f\"\\033[38;5;79m{task}\\033[0m\")\nlog.debug(\"\\033[38;5;79m-------------------&gt;\\033[0m\")\nif self._handle_task is not None:\nwith RequestsStream._lock:\ntry:\nresult = self._handle_task(task)\nexcept Exception as err:\nlog.error(err)\nif self._persistent:\nif task.HasField(\"event\"):\nself._queue.put(persistent.nack_request(task))\nresult = None\nif self._persistent:\nif task.HasField(\"event\"):\nack_request = persistent.ack_request(task)\nself._queue.put(ack_request)\nself._results.append(result)\ndef stop(self):\nself._stop.set()\ndef collect(self, task):\n\"\"\"Adds a task to the tasks queue.\"\"\"\nif task is not None:\nself._tasks.put(task)\nreturn self\ndef update(self, task):\nif self._stop.is_set():\nreturn self\nself.handle_task(task)\n# self.collect(task)\n# if not self._tasks.empty():\n#     task = self._tasks.get(lock=False)\n#     self.handle_task(task)\n#     self._tasks.task_done()\nreturn self\n</code></pre>"},{"location":"reference/eventstore_grpc/subscriptions/requests_stream/#eventstore_grpc.subscriptions.requests_stream.RequestsStream.collect","title":"<code>collect(task)</code>","text":"<p>Adds a task to the tasks queue.</p> Source code in <code>src/eventstore_grpc/subscriptions/requests_stream.py</code> <pre><code>def collect(self, task):\n\"\"\"Adds a task to the tasks queue.\"\"\"\nif task is not None:\nself._tasks.put(task)\nreturn self\n</code></pre>"},{"location":"reference/eventstore_grpc/subscriptions/subscription/","title":"Subscription","text":"<p>A Subscription Object.</p>"},{"location":"reference/eventstore_grpc/subscriptions/subscription/#eventstore_grpc.subscriptions.subscription.Subscription","title":"<code>Subscription</code>","text":"<p>         Bases: <code>threading.Thread</code></p> <p>A Subscription Object</p> <p>This object spawns a new thread and runs a custom callback against each of the elements yielded from the stream iterator.</p> <p>Attributes:</p> Name Type Description <code>_lock</code> <p>a threading.RLock used to sync.</p> Source code in <code>src/eventstore_grpc/subscriptions/subscription.py</code> <pre><code>class Subscription(threading.Thread):\n\"\"\"A Subscription Object\n    This object spawns a new thread and runs a custom callback against each of the\n    elements yielded from the stream iterator.\n    Attributes:\n        _lock: a threading.RLock used to sync.\n    \"\"\"\n_lock = threading.RLock()\ndef __init__(\nself,\nrequests_stream: RequestsStream,\nstub=None,\nmanager=None,\nname=None,\n**kwargs,\n):\n\"\"\"Initializes the subscription.\"\"\"\nthreading.Thread.__init__(self, name=name)\nself._requests_stream = requests_stream\nself._responses_stream = None\nself._stub = stub\nself._unsubscribed = threading.Event()\nself._manager = manager\nself.call_options = kwargs\n@property\ndef grpc_request(self):\nif not isinstance(self._stub, persistent_pb2_grpc.PersistentSubscriptionsStub):\ngrpc_request = next(self._requests_stream)\nelse:\ngrpc_request = self._requests_stream\nreturn grpc_request\ndef revoke(self):\nlog.debug(f\"\\033[38;5;190mRevoking subscribtion to {self.name}.\\033[0m\")\nlog.debug(\"\\033[38;5;190mStopping stream.\\033[0m\")\nself._requests_stream.stop()\nself._unsubscribed.set()\nlog.debug(\"\\033[38;5;190mSet unsubscribed event.\\033[0m\")\nif self._responses_stream is not None:\nlog.debug(\"\\033[38;5;190mCancelling grpc request.\\033[0m\")\nself._responses_stream.cancel()\nlog.debug(\"\\033[38;5;190mGRPC request cancelled.\\033[0m\")\nreturn self\n@property\ndef revoked(self):\nreturn self._unsubscribed.is_set()\n@property\ndef results(self):\nreturn self._requests_stream._results\ndef run(self, *args, **kwargs):\n\"\"\"Runs the thread activity.\"\"\"\nlog.debug(f\"{self.name:^10} activity started.\")\nreq = self.grpc_request\nself._responses_stream = self._stub.Read(req, **self.call_options)\ntry:\nfor response in self._responses_stream:\nif self.revoked:\nreturn self.results\nself._requests_stream.update(response)\nexcept grpc.RpcError as err:\nif err.code() == grpc.StatusCode.CANCELLED:\nlog.debug(\nf\"\\033[38;5;196mGRPC request cancelled for {self.name}\\033[0m\"\n)\nelif err.code() == grpc.StatusCode.UNKNOWN:\nlog.debug(\nf\"\\033[38;5;209m[REVOKING SUBSCRIPTION {self.name}]: {err.code()} - {err.details()}\\033[0m\"\n)\nlog.debug(f\"\\033[38;5;209m{err}\\033[0m\")\nself.revoke()\nif self.name in self._manager._registry:\ndel self._manager._registry[self.name]\nreturn self.results\nelse:\nraise err  # pragma: nocover\nreturn self.results\n</code></pre>"},{"location":"reference/eventstore_grpc/subscriptions/subscription/#eventstore_grpc.subscriptions.subscription.Subscription.__init__","title":"<code>__init__(requests_stream, stub=None, manager=None, name=None, **kwargs)</code>","text":"<p>Initializes the subscription.</p> Source code in <code>src/eventstore_grpc/subscriptions/subscription.py</code> <pre><code>def __init__(\nself,\nrequests_stream: RequestsStream,\nstub=None,\nmanager=None,\nname=None,\n**kwargs,\n):\n\"\"\"Initializes the subscription.\"\"\"\nthreading.Thread.__init__(self, name=name)\nself._requests_stream = requests_stream\nself._responses_stream = None\nself._stub = stub\nself._unsubscribed = threading.Event()\nself._manager = manager\nself.call_options = kwargs\n</code></pre>"},{"location":"reference/eventstore_grpc/subscriptions/subscription/#eventstore_grpc.subscriptions.subscription.Subscription.run","title":"<code>run(*args, **kwargs)</code>","text":"<p>Runs the thread activity.</p> Source code in <code>src/eventstore_grpc/subscriptions/subscription.py</code> <pre><code>def run(self, *args, **kwargs):\n\"\"\"Runs the thread activity.\"\"\"\nlog.debug(f\"{self.name:^10} activity started.\")\nreq = self.grpc_request\nself._responses_stream = self._stub.Read(req, **self.call_options)\ntry:\nfor response in self._responses_stream:\nif self.revoked:\nreturn self.results\nself._requests_stream.update(response)\nexcept grpc.RpcError as err:\nif err.code() == grpc.StatusCode.CANCELLED:\nlog.debug(\nf\"\\033[38;5;196mGRPC request cancelled for {self.name}\\033[0m\"\n)\nelif err.code() == grpc.StatusCode.UNKNOWN:\nlog.debug(\nf\"\\033[38;5;209m[REVOKING SUBSCRIPTION {self.name}]: {err.code()} - {err.details()}\\033[0m\"\n)\nlog.debug(f\"\\033[38;5;209m{err}\\033[0m\")\nself.revoke()\nif self.name in self._manager._registry:\ndel self._manager._registry[self.name]\nreturn self.results\nelse:\nraise err  # pragma: nocover\nreturn self.results\n</code></pre>"},{"location":"reference/eventstore_grpc/subscriptions/subscriptions_manager/","title":"Subscriptions manager","text":"<p>Subscriptions Manager.</p> <p>Dev notes:</p> <p>There should be 2 different \"types\" of subscriptions involved:     1.  OneWay Subscription: the server streams events to the client, which handles them.     2.  TwoWay Subscription: the server streams events to the client, which handles them and         tells back the server which events to consider acknowledged and which ones not.</p> <p>In both cases, there should be some mechanism for the client to cancel the gRPC call. If this can be controlled by the user of the library, this means that the channel (or the stub) must be reachable from inside the thread. This shouldn't be a problem, since both grpc channels and stubs should be thread-safe: https://github.com/grpc/grpc/issues/9320</p> <p>In both cases, the library's user must control over what he can do with an event, probably by providing a callback to invoke within the thread (streaming) loop.</p> <p>In case of the TwoWay Subscription, we could consider instructing the library's user to raise a specific Exception carrying the information to complete the Nack request, or provide a default mechanism in case of different exceptions.</p>"},{"location":"reference/eventstore_grpc/subscriptions/subscriptions_manager/#eventstore_grpc.subscriptions.subscriptions_manager.SubscriptionsManager","title":"<code>SubscriptionsManager</code>","text":"<p>A Subscription Manager.</p> Source code in <code>src/eventstore_grpc/subscriptions/subscriptions_manager.py</code> <pre><code>class SubscriptionsManager:\n\"\"\"A Subscription Manager.\"\"\"\ndef __init__(self, channel: grpc.Channel):\nself._registry: dict[str, Subscription] = {}\nself._channel = channel\nself._streams_stub = streams_pb2_grpc.StreamsStub(self._channel)\nself._persistent_stub = persistent_pb2_grpc.PersistentSubscriptionsStub(\nself._channel\n)\n@property\ndef subscription_ids(self):\nreturn [elm for elm in self._registry.keys()]\ndef subscribe(\nself,\n):\nraise NotImplementedError\ndef register(\nself, subscription: Subscription, id_: str | UUID | None = None\n) -&gt; str:\n\"\"\"Registers a subscription to the registry.\"\"\"\nid_ = id_ or uuid.uuid4()\nif id_ in self._registry:\nraise ValueError(f\"Already Registered: {id_}\")\nself._registry[str(id_)] = subscription\nreturn str(id_)\ndef subscribe_to_stream(\nself,\nstream: str,\nfrom_revision: Union[str, int] = constants.START,\nresolve_link_to_s: bool = False,\nhandler: Optional[Callable] = None,\n**kwargs,\n):\n# Create a requests stream.\nrequest = streams.get_stream_subscription_request(\nstream=stream,\nfrom_revision=from_revision,\nresolve_link_to_s=resolve_link_to_s,\n)\nrequests_stream = RequestsStream(handler=handler, queue=[request])\n# Create a new Subscription object.\nstub = self._streams_stub\nsubscription = Subscription(\nrequests_stream=requests_stream,\nstub=stub,\nmanager=self,\nname=stream,\n**kwargs,\n)\n# Register the object to the manager.\nsubscription_id = self.register(subscription, id_=stream)\n# Run it.\nsubscription.start()\nreturn subscription_id\ndef subscribe_to_all(\nself,\nfrom_position: str | dict[str, int] = constants.START,\nresolve_link_to_s: bool = False,\nfilters: Optional[Dict] = None,\nhandler: Optional[Callable] = None,\n**kwargs,\n):\n# Create a requests stream.\nrequest = streams.get_all_subscription_request(\nfrom_position=from_position,\nresolve_link_to_s=resolve_link_to_s,\nfilters=filters,\n)\nrequests_stream = RequestsStream(handler=handler, queue=[request])\n# Create a new Subscription object.\nstub = self._streams_stub\nname = \"$all\"\nsubscription = Subscription(\nrequests_stream=requests_stream,\nstub=stub,\nmanager=self,\nname=name,\n**kwargs,\n)\n# Register the object to the manager.\nsubscription_id = self.register(subscription, id_=name)\n# Run it.\nsubscription.start()\nreturn subscription_id\ndef subscribe_persistent(\nself,\nstream: str,\ngroup_name: str,\nbuffer_size: int = 10,\nhandler: Optional[Callable] = None,\n**kwargs,\n):\n# Create a requests stream.\nrequest = persistent.options_request(\nstream=stream, group_name=group_name, buffer_size=buffer_size\n)\nrequests_stream = RequestsStream(\nhandler=handler, queue=[request], persistent=True\n)\n# Create a new Subscription object.\nstub = self._persistent_stub\nname = f\"{stream}-{group_name}\"\nsubscription = Subscription(\nrequests_stream=requests_stream,\nstub=stub,\nmanager=self,\nname=name,\n**kwargs,\n)\n# Register the object to the manager.\nsubscription_id = self.register(subscription, id_=name)\n# Run it.\nsubscription.start()\nreturn subscription_id\ndef unsubscribe(self, stream_name: str, timeout: int = 5):\n\"\"\"Unsubscribes from a stream.\"\"\"\nif stream_name not in self._registry:\nlog.error(f\"Subscription not found: {stream_name}\")\nreturn None\nsubscription: Subscription = self._registry.pop(stream_name)\nsubscription.revoke()\nlog.info(\"\\033[38;5;190mSubscription revoked.\\033[0m\")\nreturn subscription.join(timeout=timeout)\n</code></pre>"},{"location":"reference/eventstore_grpc/subscriptions/subscriptions_manager/#eventstore_grpc.subscriptions.subscriptions_manager.SubscriptionsManager.register","title":"<code>register(subscription, id_=None)</code>","text":"<p>Registers a subscription to the registry.</p> Source code in <code>src/eventstore_grpc/subscriptions/subscriptions_manager.py</code> <pre><code>def register(\nself, subscription: Subscription, id_: str | UUID | None = None\n) -&gt; str:\n\"\"\"Registers a subscription to the registry.\"\"\"\nid_ = id_ or uuid.uuid4()\nif id_ in self._registry:\nraise ValueError(f\"Already Registered: {id_}\")\nself._registry[str(id_)] = subscription\nreturn str(id_)\n</code></pre>"},{"location":"reference/eventstore_grpc/subscriptions/subscriptions_manager/#eventstore_grpc.subscriptions.subscriptions_manager.SubscriptionsManager.unsubscribe","title":"<code>unsubscribe(stream_name, timeout=5)</code>","text":"<p>Unsubscribes from a stream.</p> Source code in <code>src/eventstore_grpc/subscriptions/subscriptions_manager.py</code> <pre><code>def unsubscribe(self, stream_name: str, timeout: int = 5):\n\"\"\"Unsubscribes from a stream.\"\"\"\nif stream_name not in self._registry:\nlog.error(f\"Subscription not found: {stream_name}\")\nreturn None\nsubscription: Subscription = self._registry.pop(stream_name)\nsubscription.revoke()\nlog.info(\"\\033[38;5;190mSubscription revoked.\\033[0m\")\nreturn subscription.join(timeout=timeout)\n</code></pre>"},{"location":"reference/eventstore_grpc/users/__init__/","title":"init","text":""},{"location":"reference/eventstore_grpc/users/change_password/","title":"Change password","text":"<p>Change user's password.</p>"},{"location":"reference/eventstore_grpc/users/change_password/#eventstore_grpc.users.change_password.change_password","title":"<code>change_password(stub, login_name, current_password, new_password, **kwargs)</code>","text":"<p>Changes user's password.</p> Source code in <code>src/eventstore_grpc/users/change_password.py</code> <pre><code>def change_password(\nstub: users_pb2_grpc.UsersStub,\nlogin_name: str,\ncurrent_password: str,\nnew_password: str,\n**kwargs,\n) -&gt; users_pb2.ChangePasswordResp:\n\"\"\"Changes user's password.\"\"\"\nrequest = users_pb2.ChangePasswordReq()\noptions = users_pb2.ChangePasswordReq.Options()\noptions.login_name = login_name\noptions.current_password = current_password\noptions.new_password = new_password\nrequest.options.CopyFrom(options)\nresponse = stub.ChangePassword(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/users/create/","title":"Create","text":"<p>Create a User.</p>"},{"location":"reference/eventstore_grpc/users/create/#eventstore_grpc.users.create.create","title":"<code>create(stub, login_name, password, full_name, groups, **kwargs)</code>","text":"<p>Creates a user.</p> Source code in <code>src/eventstore_grpc/users/create.py</code> <pre><code>def create(\nstub: users_pb2_grpc.UsersStub,\nlogin_name: str,\npassword: str,\nfull_name: str,\ngroups: List[str],\n**kwargs,\n) -&gt; users_pb2.CreateResp:\n\"\"\"Creates a user.\"\"\"\nrequest = users_pb2.CreateReq()\noptions = users_pb2.CreateReq.Options()\noptions.login_name = login_name\noptions.password = password\noptions.full_name = full_name\nfor group in groups:\noptions.groups.append(group)\nrequest.options.CopyFrom(options)\nresponse = stub.Create(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/users/delete/","title":"Delete","text":"<p>Delete users.</p>"},{"location":"reference/eventstore_grpc/users/delete/#eventstore_grpc.users.delete.delete","title":"<code>delete(stub, login_name, **kwargs)</code>","text":"<p>Deletes a user.</p> Source code in <code>src/eventstore_grpc/users/delete.py</code> <pre><code>def delete(\nstub: users_pb2_grpc.UsersStub, login_name: str, **kwargs\n) -&gt; users_pb2.DeleteResp:\n\"\"\"Deletes a user.\"\"\"\nrequest = users_pb2.DeleteReq()\noptions = users_pb2.DeleteReq.Options()\noptions.login_name = login_name\nrequest.options.CopyFrom(options)\nresponse = stub.Delete(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/users/details/","title":"Details","text":"<p>Details about a user.</p>"},{"location":"reference/eventstore_grpc/users/details/#eventstore_grpc.users.details.details","title":"<code>details(stub, login_name, **kwargs)</code>","text":"<p>Gets details about a user.</p> Source code in <code>src/eventstore_grpc/users/details.py</code> <pre><code>def details(\nstub: users_pb2_grpc.UsersStub, login_name: str, **kwargs\n) -&gt; Iterable[users_pb2.DetailsResp]:\n\"\"\"Gets details about a user.\"\"\"\nrequest = users_pb2.DetailsReq()\noptions = users_pb2.DetailsReq.Options()\noptions.login_name = login_name\nrequest.options.CopyFrom(options)\nresponse = stub.Details(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/users/disable/","title":"Disable","text":"<p>Disable users.</p>"},{"location":"reference/eventstore_grpc/users/disable/#eventstore_grpc.users.disable.disable","title":"<code>disable(stub, login_name, **kwargs)</code>","text":"<p>Disables a user.</p> Source code in <code>src/eventstore_grpc/users/disable.py</code> <pre><code>def disable(\nstub: users_pb2_grpc.UsersStub, login_name: str, **kwargs\n) -&gt; users_pb2.DisableResp:\n\"\"\"Disables a user.\"\"\"\nrequest = users_pb2.DisableReq()\noptions = users_pb2.DisableReq.Options()\noptions.login_name = login_name\nrequest.options.CopyFrom(options)\nresponse = stub.Disable(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/users/enable/","title":"Enable","text":"<p>Enable users.</p>"},{"location":"reference/eventstore_grpc/users/enable/#eventstore_grpc.users.enable.enable","title":"<code>enable(stub, login_name, **kwargs)</code>","text":"<p>Enables a user.</p> Source code in <code>src/eventstore_grpc/users/enable.py</code> <pre><code>def enable(\nstub: users_pb2_grpc.UsersStub, login_name: str, **kwargs\n) -&gt; users_pb2.EnableResp:\n\"\"\"Enables a user.\"\"\"\nrequest = users_pb2.EnableReq()\noptions = users_pb2.EnableReq.Options()\noptions.login_name = login_name\nrequest.options.CopyFrom(options)\nresponse = stub.Enable(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/users/reset_password/","title":"Reset password","text":"<p>Reset user's passwords.</p>"},{"location":"reference/eventstore_grpc/users/reset_password/#eventstore_grpc.users.reset_password.reset_password","title":"<code>reset_password(stub, login_name, new_password, **kwargs)</code>","text":"<p>Resets user's password.</p> Source code in <code>src/eventstore_grpc/users/reset_password.py</code> <pre><code>def reset_password(\nstub: users_pb2_grpc.UsersStub, login_name: str, new_password: str, **kwargs\n) -&gt; users_pb2.ResetPasswordResp:\n\"\"\"Resets user's password.\"\"\"\nrequest = users_pb2.ResetPasswordReq()\noptions = users_pb2.ResetPasswordReq.Options()\noptions.login_name = login_name\noptions.new_password = new_password\nrequest.options.CopyFrom(options)\nresponse = stub.ResetPassword(request, **kwargs)\nreturn response\n</code></pre>"},{"location":"reference/eventstore_grpc/users/update/","title":"Update","text":"<p>Updates a User.</p>"},{"location":"reference/eventstore_grpc/users/update/#eventstore_grpc.users.update.update","title":"<code>update(stub, login_name=None, password=None, full_name=None, groups=None, **kwargs)</code>","text":"<p>Updates a user.</p> Source code in <code>src/eventstore_grpc/users/update.py</code> <pre><code>def update(\nstub: users_pb2_grpc.UsersStub,\nlogin_name: str | None = None,\npassword: str | None = None,\nfull_name: str | None = None,\ngroups: List[str] | None = None,\n**kwargs\n) -&gt; users_pb2.UpdateResp:\n\"\"\"Updates a user.\"\"\"\nrequest = users_pb2.UpdateReq()\noptions = users_pb2.UpdateReq.Options()\nif login_name is not None:\noptions.login_name = login_name\nif password is not None:\noptions.password = password\nif full_name is not None:\noptions.full_name = full_name\nif groups is not None:\nfor group in groups:\noptions.groups.append(group)\nrequest.options.CopyFrom(options)\nresponse = stub.Update(request, **kwargs)\nreturn response\n</code></pre>"}]}